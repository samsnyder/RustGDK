/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: ::std::os::raw::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const __DARWIN_UNIX03: ::std::os::raw::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: ::std::os::raw::c_uint = 1;
pub const __DARWIN_VERS_1050: ::std::os::raw::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: ::std::os::raw::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: ::std::os::raw::c_uint = 4096;
pub const __DARWIN_C_FULL: ::std::os::raw::c_uint = 900000;
pub const __DARWIN_C_LEVEL: ::std::os::raw::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_64_BIT_INODE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: ::std::os::raw::c_uint = 3;
pub const __PTHREAD_SIZE__: ::std::os::raw::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: ::std::os::raw::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: ::std::os::raw::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: ::std::os::raw::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: ::std::os::raw::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: ::std::os::raw::c_uint = 16;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const WORKER_DEFAULTS_SEND_QUEUE_CAPACITY: ::std::os::raw::c_uint = 4096;
pub const WORKER_DEFAULTS_RECEIVE_QUEUE_CAPACITY: ::std::os::raw::c_uint =
    4096;
pub const WORKER_DEFAULTS_LOG_MESSAGE_QUEUE_CAPACITY: ::std::os::raw::c_uint =
    256;
pub const WORKER_DEFAULTS_BUILT_IN_METRICS_REPORT_PERIOD_MILLIS:
          ::std::os::raw::c_uint =
    5000;
pub const WORKER_DEFAULTS_CONNECTION_TIMEOUT_MILLIS: ::std::os::raw::c_uint =
    60000;
pub const WORKER_DEFAULTS_TCP_MULTIPLEX_LEVEL: ::std::os::raw::c_uint = 32;
pub const WORKER_DEFAULTS_TCP_SEND_BUFFER_SIZE: ::std::os::raw::c_uint =
    65536;
pub const WORKER_DEFAULTS_TCP_RECEIVE_BUFFER_SIZE: ::std::os::raw::c_uint =
    65536;
pub const WORKER_DEFAULTS_TCP_NO_DELAY: ::std::os::raw::c_uint = 0;
pub const WORKER_DEFAULTS_RAKNET_HEARTBEAT_TIMEOUT_MILLIS:
          ::std::os::raw::c_uint =
    60000;
pub const WORKER_DEFAULTS_LOG_PREFIX: &'static [u8; 14usize] =
    b"protocol-log-\x00";
pub const WORKER_DEFAULTS_MAX_LOG_FILES: ::std::os::raw::c_uint = 10;
pub const WORKER_DEFAULTS_MAX_LOG_FILE_SIZE_BYTES: ::std::os::raw::c_uint =
    1048576;
pub const SCHEMA_MAP_KEY_FIELD_ID: ::std::os::raw::c_uint = 1;
pub const SCHEMA_MAP_VALUE_FIELD_ID: ::std::os::raw::c_uint = 2;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[::std::os::raw::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<::std::os::raw::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::std::mem::size_of::<__darwin_pthread_handler_rec>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::std::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_mutexattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::std::mem::size_of::<_opaque_pthread_t>() , 8192usize , concat
               ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::std::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type Worker_EntityId = i64;
pub type Worker_ComponentId = u32;
pub type Worker_RequestId = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandRequest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_CommandResponse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentData {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_ComponentUpdate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Connection {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_ConnectionFuture {
    _unused: [u8; 0],
}
/** A single query constraint. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Constraint {
    /** The type of constraint, defined using Worker_ConstraintType. */
    pub constraint_type: u8,
    pub __bindgen_anon_1: Worker_Constraint__bindgen_ty_1,
}
/** Union with fields corresponding to each constraint type. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Constraint__bindgen_ty_1 {
    pub entity_id_constraint: __BindgenUnionField<Worker_EntityIdConstraint>,
    pub component_constraint: __BindgenUnionField<Worker_ComponentConstraint>,
    pub sphere_constraint: __BindgenUnionField<Worker_SphereConstraint>,
    pub and_constraint: __BindgenUnionField<Worker_AndConstraint>,
    pub or_constraint: __BindgenUnionField<Worker_OrConstraint>,
    pub not_constraint: __BindgenUnionField<Worker_NotConstraint>,
    pub bindgen_union_field: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_Worker_Constraint__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<Worker_Constraint__bindgen_ty_1>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( Worker_Constraint__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<Worker_Constraint__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint__bindgen_ty_1 ) ) .
                entity_id_constraint as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) , "::" , stringify ! (
                entity_id_constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint__bindgen_ty_1 ) ) .
                component_constraint as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) , "::" , stringify ! (
                component_constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint__bindgen_ty_1 ) ) .
                sphere_constraint as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) , "::" , stringify ! (
                sphere_constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint__bindgen_ty_1 ) ) .
                and_constraint as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) , "::" , stringify ! (
                and_constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint__bindgen_ty_1 ) ) .
                or_constraint as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) , "::" , stringify ! (
                or_constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint__bindgen_ty_1 ) ) .
                not_constraint as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_Constraint__bindgen_ty_1 ) , "::" , stringify ! (
                not_constraint ) ));
}
impl Clone for Worker_Constraint__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Worker_Constraint() {
    assert_eq!(::std::mem::size_of::<Worker_Constraint>() , 40usize , concat !
               ( "Size of: " , stringify ! ( Worker_Constraint ) ));
    assert_eq! (::std::mem::align_of::<Worker_Constraint>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_Constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Constraint ) ) . constraint_type
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Constraint ) ,
                "::" , stringify ! ( constraint_type ) ));
}
impl Clone for Worker_Constraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_DeploymentListFuture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_Locator {
    _unused: [u8; 0],
}
/** An op list, usually returned by WorkerProtocol_Connection_GetOpList. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_OpList {
    pub ops: *mut Worker_Op,
    pub op_count: u32,
}
#[test]
fn bindgen_test_layout_Worker_OpList() {
    assert_eq!(::std::mem::size_of::<Worker_OpList>() , 16usize , concat ! (
               "Size of: " , stringify ! ( Worker_OpList ) ));
    assert_eq! (::std::mem::align_of::<Worker_OpList>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_OpList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_OpList ) ) . ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_OpList ) , "::"
                , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_OpList ) ) . op_count as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_OpList ) , "::"
                , stringify ! ( op_count ) ));
}
impl Clone for Worker_OpList {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnasphotInputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotOutputStream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Worker_SnapshotInputStream {
    _unused: [u8; 0],
}
pub mod Worker_LogLevel {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_LOG_LEVEL_DEBUG: Type = 1;
    pub const WORKER_LOG_LEVEL_INFO: Type = 2;
    pub const WORKER_LOG_LEVEL_WARN: Type = 3;
    pub const WORKER_LOG_LEVEL_ERROR: Type = 4;
    pub const WORKER_LOG_LEVEL_FATAL: Type = 5;
}
pub mod Worker_StatusCode {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_STATUS_CODE_SUCCESS: Type = 1;
    pub const WORKER_STATUS_CODE_TIMEOUT: Type = 2;
    pub const WORKER_STATUS_CODE_NOT_FOUND: Type = 3;
    pub const WORKER_STATUS_CODE_AUTHORITY_LOST: Type = 4;
    pub const WORKER_STATUS_CODE_PERMISSION_DENIED: Type = 5;
    pub const WORKER_STATUS_CODE_APPLICATION_ERROR: Type = 6;
    pub const WORKER_STATUS_CODE_INTERNAL_ERROR: Type = 7;
}
pub mod Worker_Authority {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_AUTHORITY_NOT_AUTHORITATIVE: Type = 0;
    pub const WORKER_AUTHORITY_AUTHORITATIVE: Type = 1;
    pub const WORKER_AUTHORITY_AUTHORITY_LOSS_IMMINENT: Type = 2;
}
/** Parameters for sending a log message to SpatialOS. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_LogMessage {
    /** The severity of the log message; defined in the Worker_LogLevel enumeration. */
    pub level: u8,
    /** The name of the logger. */
    pub logger_name: *const ::std::os::raw::c_char,
    /** The full log message. */
    pub message: *const ::std::os::raw::c_char,
    /** The ID of the entity this message relates to, or NULL for none. */
    pub entity_id: *const Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_LogMessage() {
    assert_eq!(::std::mem::size_of::<Worker_LogMessage>() , 32usize , concat !
               ( "Size of: " , stringify ! ( Worker_LogMessage ) ));
    assert_eq! (::std::mem::align_of::<Worker_LogMessage>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_LogMessage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LogMessage ) ) . level as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_LogMessage ) ,
                "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LogMessage ) ) . logger_name as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_LogMessage ) ,
                "::" , stringify ! ( logger_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LogMessage ) ) . message as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_LogMessage ) ,
                "::" , stringify ! ( message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LogMessage ) ) . entity_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_LogMessage ) ,
                "::" , stringify ! ( entity_id ) ));
}
impl Clone for Worker_LogMessage {
    fn clone(&self) -> Self { *self }
}
/** Parameters for a gauge metric. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_GaugeMetric {
    pub key: *const ::std::os::raw::c_char,
    pub value: f64,
}
#[test]
fn bindgen_test_layout_Worker_GaugeMetric() {
    assert_eq!(::std::mem::size_of::<Worker_GaugeMetric>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( Worker_GaugeMetric ) ));
    assert_eq! (::std::mem::align_of::<Worker_GaugeMetric>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_GaugeMetric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_GaugeMetric ) ) . key as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_GaugeMetric ) ,
                "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_GaugeMetric ) ) . value as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_GaugeMetric ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for Worker_GaugeMetric {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_HistogramMetricBucket {
    pub upper_bound: f64,
    pub samples: u32,
}
#[test]
fn bindgen_test_layout_Worker_HistogramMetricBucket() {
    assert_eq!(::std::mem::size_of::<Worker_HistogramMetricBucket>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( Worker_HistogramMetricBucket ) ));
    assert_eq! (::std::mem::align_of::<Worker_HistogramMetricBucket>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_HistogramMetricBucket )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_HistogramMetricBucket ) ) .
                upper_bound as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_HistogramMetricBucket ) , "::" , stringify ! (
                upper_bound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_HistogramMetricBucket ) ) .
                samples as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_HistogramMetricBucket ) , "::" , stringify ! ( samples
                ) ));
}
impl Clone for Worker_HistogramMetricBucket {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_HistogramMetric {
    pub key: *const ::std::os::raw::c_char,
    pub sum: f64,
    pub bucket_count: u32,
    pub buckets: *const Worker_HistogramMetricBucket,
}
#[test]
fn bindgen_test_layout_Worker_HistogramMetric() {
    assert_eq!(::std::mem::size_of::<Worker_HistogramMetric>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_HistogramMetric )
               ));
    assert_eq! (::std::mem::align_of::<Worker_HistogramMetric>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_HistogramMetric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_HistogramMetric ) ) . key as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_HistogramMetric
                ) , "::" , stringify ! ( key ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_HistogramMetric ) ) . sum as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_HistogramMetric
                ) , "::" , stringify ! ( sum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_HistogramMetric ) ) . bucket_count
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_HistogramMetric
                ) , "::" , stringify ! ( bucket_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_HistogramMetric ) ) . buckets as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_HistogramMetric
                ) , "::" , stringify ! ( buckets ) ));
}
impl Clone for Worker_HistogramMetric {
    fn clone(&self) -> Self { *self }
}
/** Parameters for sending metrics to SpatialOS. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Metrics {
    /** The load value of this worker. If NULL, do not report load. */
    pub load: *const f64,
    /** The number of gauge metrics. */
    pub gauge_metric_count: u32,
    /** Array of gauge metrics. */
    pub gauge_metrics: *const Worker_GaugeMetric,
    /** The number of histogram metrics. */
    pub histogram_metric_count: u32,
    /** Array of histogram metrics. */
    pub histogram_metrics: *const Worker_HistogramMetric,
}
#[test]
fn bindgen_test_layout_Worker_Metrics() {
    assert_eq!(::std::mem::size_of::<Worker_Metrics>() , 40usize , concat ! (
               "Size of: " , stringify ! ( Worker_Metrics ) ));
    assert_eq! (::std::mem::align_of::<Worker_Metrics>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_Metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Metrics ) ) . load as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Metrics ) , "::"
                , stringify ! ( load ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Metrics ) ) . gauge_metric_count
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Metrics ) , "::"
                , stringify ! ( gauge_metric_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Metrics ) ) . gauge_metrics as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Metrics ) , "::"
                , stringify ! ( gauge_metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Metrics ) ) .
                histogram_metric_count as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_Metrics ) , "::"
                , stringify ! ( histogram_metric_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Metrics ) ) . histogram_metrics as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Metrics ) , "::"
                , stringify ! ( histogram_metrics ) ));
}
impl Clone for Worker_Metrics {
    fn clone(&self) -> Self { *self }
}
pub type Worker_CommandRequestHandle = ::std::os::raw::c_void;
pub type Worker_CommandResponseHandle = ::std::os::raw::c_void;
pub type Worker_ComponentDataHandle = ::std::os::raw::c_void;
pub type Worker_ComponentUpdateHandle = ::std::os::raw::c_void;
pub type Worker_CommandRequestFree =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_CommandRequestHandle)>;
pub type Worker_CommandResponseFree =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_CommandResponseHandle)>;
pub type Worker_ComponentDataFree =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_ComponentDataHandle)>;
pub type Worker_ComponentUpdateFree =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_ComponentUpdateHandle)>;
pub type Worker_CommandRequestCopy =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_CommandRequestHandle)
                              -> *mut Worker_CommandRequestHandle>;
pub type Worker_CommandResponseCopy =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_CommandResponseHandle)
                              -> *mut Worker_CommandResponseHandle>;
pub type Worker_ComponentDataCopy =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_ComponentDataHandle)
                              -> *mut Worker_ComponentDataHandle>;
pub type Worker_ComponentUpdateCopy =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_ComponentUpdateHandle)
                              -> *mut Worker_ComponentUpdateHandle>;
pub type Worker_CommandRequestDeserialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               source:
                                                   *mut Schema_CommandRequest,
                                               handle_out:
                                                   *mut *mut Worker_CommandRequestHandle)
                              -> u8>;
pub type Worker_CommandResponseDeserialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               source:
                                                   *mut Schema_CommandResponse,
                                               handle_out:
                                                   *mut *mut Worker_CommandResponseHandle)
                              -> u8>;
pub type Worker_ComponentDataDeserialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               source:
                                                   *mut Schema_ComponentData,
                                               handle_out:
                                                   *mut *mut Worker_ComponentDataHandle)
                              -> u8>;
pub type Worker_ComponentUpdateDeserialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               source:
                                                   *mut Schema_ComponentUpdate,
                                               handle_out:
                                                   *mut *mut Worker_ComponentUpdateHandle)
                              -> u8>;
pub type Worker_CommandRequestSerialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_CommandRequestHandle,
                                               target_out:
                                                   *mut *mut Schema_CommandRequest)>;
pub type Worker_CommandResponseSerialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_CommandResponseHandle,
                                               target_out:
                                                   *mut *mut Schema_CommandResponse)>;
pub type Worker_ComponentDataSerialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_ComponentDataHandle,
                                               target_out:
                                                   *mut *mut Schema_ComponentData)>;
pub type Worker_ComponentUpdateSerialize =
    ::std::option::Option<unsafe extern "C" fn(component_id:
                                                   Worker_ComponentId,
                                               user_data:
                                                   *mut ::std::os::raw::c_void,
                                               handle:
                                                   *mut Worker_ComponentUpdateHandle,
                                               target_out:
                                                   *mut *mut Schema_ComponentUpdate)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ComponentVtable {
    /**
   * Component ID that this vtable is for. If this is the default vtable, this field is ignored.
   */
    pub component_id: Worker_ComponentId,
    /** User data which will be passed directly to the callbacks supplied below. */
    pub user_data: *mut ::std::os::raw::c_void,
    pub command_request_free: Worker_CommandRequestFree,
    pub command_request_copy: Worker_CommandRequestCopy,
    pub command_request_deserialize: Worker_CommandRequestDeserialize,
    pub command_request_serialize: Worker_CommandRequestSerialize,
    pub command_response_free: Worker_CommandResponseFree,
    pub command_response_copy: Worker_CommandResponseCopy,
    pub command_response_deserialize: Worker_CommandResponseDeserialize,
    pub command_response_serialize: Worker_CommandResponseSerialize,
    pub component_data_free: Worker_ComponentDataFree,
    pub component_data_copy: Worker_ComponentDataCopy,
    pub component_data_deserialize: Worker_ComponentDataDeserialize,
    pub component_data_serialize: Worker_ComponentDataSerialize,
    pub component_update_free: Worker_ComponentUpdateFree,
    pub component_update_copy: Worker_ComponentUpdateCopy,
    pub component_update_deserialize: Worker_ComponentUpdateDeserialize,
    pub component_update_serialize: Worker_ComponentUpdateSerialize,
}
#[test]
fn bindgen_test_layout_Worker_ComponentVtable() {
    assert_eq!(::std::mem::size_of::<Worker_ComponentVtable>() , 144usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_ComponentVtable )
               ));
    assert_eq! (::std::mem::align_of::<Worker_ComponentVtable>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_ComponentVtable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) . component_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) . user_data as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( user_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_request_free as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_request_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_request_copy as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_request_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_request_deserialize as * const _ as usize } , 32usize
                , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_request_deserialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_request_serialize as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_request_serialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_response_free as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_response_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_response_copy as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_response_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_response_deserialize as * const _ as usize } , 64usize
                , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_response_deserialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                command_response_serialize as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( command_response_serialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_data_free as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_data_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_data_copy as * const _ as usize } , 88usize , concat
                ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_data_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_data_deserialize as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_data_deserialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_data_serialize as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_data_serialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_update_free as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_update_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_update_copy as * const _ as usize } , 120usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_update_copy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_update_deserialize as * const _ as usize } ,
                128usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_update_deserialize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentVtable ) ) .
                component_update_serialize as * const _ as usize } , 136usize
                , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentVtable
                ) , "::" , stringify ! ( component_update_serialize ) ));
}
impl Clone for Worker_ComponentVtable {
    fn clone(&self) -> Self { *self }
}
/**
 * An object used to represent a command request by either raw schema data or some user-defined
 * handle type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CommandRequest {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_CommandRequest,
    pub user_handle: *mut Worker_CommandRequestHandle,
}
#[test]
fn bindgen_test_layout_Worker_CommandRequest() {
    assert_eq!(::std::mem::size_of::<Worker_CommandRequest>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_CommandRequest )
               ));
    assert_eq! (::std::mem::align_of::<Worker_CommandRequest>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_CommandRequest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequest ) ) . reserved as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequest )
                , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequest ) ) . component_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequest )
                , "::" , stringify ! ( component_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequest ) ) . schema_type
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequest )
                , "::" , stringify ! ( schema_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequest ) ) . user_handle
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequest )
                , "::" , stringify ! ( user_handle ) ));
}
impl Clone for Worker_CommandRequest {
    fn clone(&self) -> Self { *self }
}
/**
 * An object used to represent a command response by either raw schema data or some user-defined
 * handle type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CommandResponse {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_CommandResponse,
    pub user_handle: *mut Worker_CommandResponseHandle,
}
#[test]
fn bindgen_test_layout_Worker_CommandResponse() {
    assert_eq!(::std::mem::size_of::<Worker_CommandResponse>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_CommandResponse )
               ));
    assert_eq! (::std::mem::align_of::<Worker_CommandResponse>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_CommandResponse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponse ) ) . reserved as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandResponse
                ) , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponse ) ) . component_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandResponse
                ) , "::" , stringify ! ( component_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponse ) ) . schema_type
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandResponse
                ) , "::" , stringify ! ( schema_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponse ) ) . user_handle
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandResponse
                ) , "::" , stringify ! ( user_handle ) ));
}
impl Clone for Worker_CommandResponse {
    fn clone(&self) -> Self { *self }
}
/**
 * An object used to represent a component data snapshot by either raw schema data or some
 * user-defined handle type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ComponentData {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentData,
    pub user_handle: *mut Worker_ComponentDataHandle,
}
#[test]
fn bindgen_test_layout_Worker_ComponentData() {
    assert_eq!(::std::mem::size_of::<Worker_ComponentData>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_ComponentData )
               ));
    assert_eq! (::std::mem::align_of::<Worker_ComponentData>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_ComponentData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentData ) ) . reserved as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentData )
                , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentData ) ) . component_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentData )
                , "::" , stringify ! ( component_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentData ) ) . schema_type as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentData )
                , "::" , stringify ! ( schema_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentData ) ) . user_handle as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentData )
                , "::" , stringify ! ( user_handle ) ));
}
impl Clone for Worker_ComponentData {
    fn clone(&self) -> Self { *self }
}
/**
 * An object used to represent a component update by either raw schema data or some user-defined
 * handle type.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ComponentUpdate {
    pub reserved: *mut ::std::os::raw::c_void,
    pub component_id: Worker_ComponentId,
    pub schema_type: *mut Schema_ComponentUpdate,
    pub user_handle: *mut Worker_ComponentUpdateHandle,
}
#[test]
fn bindgen_test_layout_Worker_ComponentUpdate() {
    assert_eq!(::std::mem::size_of::<Worker_ComponentUpdate>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_ComponentUpdate )
               ));
    assert_eq! (::std::mem::align_of::<Worker_ComponentUpdate>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_ComponentUpdate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentUpdate ) ) . reserved as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentUpdate
                ) , "::" , stringify ! ( reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentUpdate ) ) . component_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentUpdate
                ) , "::" , stringify ! ( component_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentUpdate ) ) . schema_type
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentUpdate
                ) , "::" , stringify ! ( schema_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentUpdate ) ) . user_handle
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_ComponentUpdate
                ) , "::" , stringify ! ( user_handle ) ));
}
impl Clone for Worker_ComponentUpdate {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /** Acquire a reference to extend the lifetime of a command request owned by the SDK. */
    pub fn Worker_AcquireCommandRequest(request: *const Worker_CommandRequest)
     -> *mut Worker_CommandRequest;
}
extern "C" {
    /** Acquire a reference to extend the lifetime of a command response owned by the SDK. */
    pub fn Worker_AcquireCommandResponse(response:
                                             *const Worker_CommandResponse)
     -> *mut Worker_CommandResponse;
}
extern "C" {
    /** Acquire a reference to extend the lifetime of a component data snapshot owned by the SDK. */
    pub fn Worker_AcquireComponentData(data: *const Worker_ComponentData)
     -> *mut Worker_ComponentData;
}
extern "C" {
    /** Acquire a reference to extend the lifetime of a component update owned by the SDK. */
    pub fn Worker_AcquireComponentUpdate(update:
                                             *const Worker_ComponentUpdate)
     -> *mut Worker_ComponentUpdate;
}
extern "C" {
    /** Release a reference obtained by Worker_AcquireCommandRequest. */
    pub fn Worker_ReleaseCommandRequest(request: *mut Worker_CommandRequest);
}
extern "C" {
    /** Release a reference obtained by Worker_AcquireCommandResponse. */
    pub fn Worker_ReleaseCommandResponse(response:
                                             *mut Worker_CommandResponse);
}
extern "C" {
    /** Release a reference obtained by Worker_AcquireComponentData. */
    pub fn Worker_ReleaseComponentData(data: *mut Worker_ComponentData);
}
extern "C" {
    /** Release a reference obtained by Worker_AcquireComponentUpdate. */
    pub fn Worker_ReleaseComponentUpdate(update: *mut Worker_ComponentUpdate);
}
/** Represents an entity with an ID and a component data snapshot. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Entity {
    /** The ID of the entity. */
    pub entity_id: Worker_EntityId,
    /** Number of components for the entity. */
    pub component_count: u32,
    /** Array of initial component data for the entity. */
    pub components: *const Worker_ComponentData,
}
#[test]
fn bindgen_test_layout_Worker_Entity() {
    assert_eq!(::std::mem::size_of::<Worker_Entity>() , 24usize , concat ! (
               "Size of: " , stringify ! ( Worker_Entity ) ));
    assert_eq! (::std::mem::align_of::<Worker_Entity>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_Entity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Entity ) ) . entity_id as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Entity ) , "::"
                , stringify ! ( entity_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Entity ) ) . component_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Entity ) , "::"
                , stringify ! ( component_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Entity ) ) . components as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Entity ) , "::"
                , stringify ! ( components ) ));
}
impl Clone for Worker_Entity {
    fn clone(&self) -> Self { *self }
}
pub mod Worker_ConstraintType {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_CONSTRAINT_TYPE_ENTITY_ID: Type = 1;
    pub const WORKER_CONSTRAINT_TYPE_COMPONENT: Type = 2;
    pub const WORKER_CONSTRAINT_TYPE_SPHERE: Type = 3;
    pub const WORKER_CONSTRAINT_TYPE_AND: Type = 4;
    pub const WORKER_CONSTRAINT_TYPE_OR: Type = 5;
    pub const WORKER_CONSTRAINT_TYPE_NOT: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_EntityIdConstraint {
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_EntityIdConstraint() {
    assert_eq!(::std::mem::size_of::<Worker_EntityIdConstraint>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_EntityIdConstraint ) ));
    assert_eq! (::std::mem::align_of::<Worker_EntityIdConstraint>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_EntityIdConstraint )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityIdConstraint ) ) . entity_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_EntityIdConstraint ) , "::" , stringify ! ( entity_id )
                ));
}
impl Clone for Worker_EntityIdConstraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ComponentConstraint {
    pub component_id: Worker_ComponentId,
}
#[test]
fn bindgen_test_layout_Worker_ComponentConstraint() {
    assert_eq!(::std::mem::size_of::<Worker_ComponentConstraint>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_ComponentConstraint ) ));
    assert_eq! (::std::mem::align_of::<Worker_ComponentConstraint>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( Worker_ComponentConstraint )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentConstraint ) ) .
                component_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ComponentConstraint ) , "::" , stringify ! (
                component_id ) ));
}
impl Clone for Worker_ComponentConstraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_SphereConstraint {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub radius: f64,
}
#[test]
fn bindgen_test_layout_Worker_SphereConstraint() {
    assert_eq!(::std::mem::size_of::<Worker_SphereConstraint>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_SphereConstraint ) ));
    assert_eq! (::std::mem::align_of::<Worker_SphereConstraint>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_SphereConstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SphereConstraint ) ) . x as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_SphereConstraint
                ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SphereConstraint ) ) . y as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_SphereConstraint
                ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SphereConstraint ) ) . z as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_SphereConstraint
                ) , "::" , stringify ! ( z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SphereConstraint ) ) . radius as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_SphereConstraint
                ) , "::" , stringify ! ( radius ) ));
}
impl Clone for Worker_SphereConstraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_AndConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
#[test]
fn bindgen_test_layout_Worker_AndConstraint() {
    assert_eq!(::std::mem::size_of::<Worker_AndConstraint>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_AndConstraint )
               ));
    assert_eq! (::std::mem::align_of::<Worker_AndConstraint>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_AndConstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AndConstraint ) ) .
                constraint_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_AndConstraint )
                , "::" , stringify ! ( constraint_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AndConstraint ) ) . constraints as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_AndConstraint )
                , "::" , stringify ! ( constraints ) ));
}
impl Clone for Worker_AndConstraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_OrConstraint {
    pub constraint_count: u32,
    pub constraints: *mut Worker_Constraint,
}
#[test]
fn bindgen_test_layout_Worker_OrConstraint() {
    assert_eq!(::std::mem::size_of::<Worker_OrConstraint>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( Worker_OrConstraint ) ));
    assert_eq! (::std::mem::align_of::<Worker_OrConstraint>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_OrConstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_OrConstraint ) ) .
                constraint_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_OrConstraint ) ,
                "::" , stringify ! ( constraint_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_OrConstraint ) ) . constraints as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_OrConstraint ) ,
                "::" , stringify ! ( constraints ) ));
}
impl Clone for Worker_OrConstraint {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_NotConstraint {
    pub constraint: *mut Worker_Constraint,
}
#[test]
fn bindgen_test_layout_Worker_NotConstraint() {
    assert_eq!(::std::mem::size_of::<Worker_NotConstraint>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( Worker_NotConstraint ) ));
    assert_eq! (::std::mem::align_of::<Worker_NotConstraint>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_NotConstraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_NotConstraint ) ) . constraint as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_NotConstraint )
                , "::" , stringify ! ( constraint ) ));
}
impl Clone for Worker_NotConstraint {
    fn clone(&self) -> Self { *self }
}
pub mod Worker_ResultType {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_RESULT_TYPE_COUNT: Type = 1;
    pub const WORKER_RESULT_TYPE_SNAPSHOT: Type = 2;
}
/** An entity query. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_EntityQuery {
    /** The constraint for this query. */
    pub constraint: Worker_Constraint,
    /** Result type for this query, using Worker_ResultType. */
    pub result_type: u8,
    /** Number of component IDs in the array for a snapshot result type. */
    pub snapshot_result_type_component_id_count: u32,
    /** Pointer to component ID data for a snapshot result type. NULL means all component IDs. */
    pub snapshot_result_type_component_ids: *const Worker_ComponentId,
}
#[test]
fn bindgen_test_layout_Worker_EntityQuery() {
    assert_eq!(::std::mem::size_of::<Worker_EntityQuery>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( Worker_EntityQuery ) ));
    assert_eq! (::std::mem::align_of::<Worker_EntityQuery>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_EntityQuery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQuery ) ) . constraint as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_EntityQuery ) ,
                "::" , stringify ! ( constraint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQuery ) ) . result_type as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_EntityQuery ) ,
                "::" , stringify ! ( result_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQuery ) ) .
                snapshot_result_type_component_id_count as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_EntityQuery ) ,
                "::" , stringify ! ( snapshot_result_type_component_id_count )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQuery ) ) .
                snapshot_result_type_component_ids as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_EntityQuery ) ,
                "::" , stringify ! ( snapshot_result_type_component_ids ) ));
}
impl Clone for Worker_EntityQuery {
    fn clone(&self) -> Self { *self }
}
/** An interest override for a particular (entity ID, component ID) pair. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_InterestOverride {
    /** The ID of the component for which interest is being overridden. */
    pub component_id: u32,
    /** Whether the worker is interested in this component. */
    pub is_interested: u8,
}
#[test]
fn bindgen_test_layout_Worker_InterestOverride() {
    assert_eq!(::std::mem::size_of::<Worker_InterestOverride>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_InterestOverride ) ));
    assert_eq! (::std::mem::align_of::<Worker_InterestOverride>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_InterestOverride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_InterestOverride ) ) .
                component_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_InterestOverride
                ) , "::" , stringify ! ( component_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_InterestOverride ) ) .
                is_interested as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_InterestOverride
                ) , "::" , stringify ! ( is_interested ) ));
}
impl Clone for Worker_InterestOverride {
    fn clone(&self) -> Self { *self }
}
/** Worker attributes that are part of a worker's runtime configuration. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_WorkerAttributes {
    /** Number of worker attributes. */
    pub attribute_count: u32,
    /** Will be NULL if there are no attributes associated with the worker. */
    pub attributes: *mut *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_WorkerAttributes() {
    assert_eq!(::std::mem::size_of::<Worker_WorkerAttributes>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_WorkerAttributes ) ));
    assert_eq! (::std::mem::align_of::<Worker_WorkerAttributes>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_WorkerAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_WorkerAttributes ) ) .
                attribute_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_WorkerAttributes
                ) , "::" , stringify ! ( attribute_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_WorkerAttributes ) ) . attributes
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_WorkerAttributes
                ) , "::" , stringify ! ( attributes ) ));
}
impl Clone for Worker_WorkerAttributes {
    fn clone(&self) -> Self { *self }
}
/** Data for a log message from the SDK. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_DisconnectOp {
    /** The reason for the disconnect. */
    pub reason: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_DisconnectOp() {
    assert_eq!(::std::mem::size_of::<Worker_DisconnectOp>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( Worker_DisconnectOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_DisconnectOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_DisconnectOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DisconnectOp ) ) . reason as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_DisconnectOp ) ,
                "::" , stringify ! ( reason ) ));
}
impl Clone for Worker_DisconnectOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a FlagUpdate operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_FlagUpdateOp {
    /** The name of the updated worker flag. */
    pub name: *const ::std::os::raw::c_char,
    /**
   * The new value of the updated worker flag.
   * A null value indicates that the flag has been deleted.
   */
    pub value: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_FlagUpdateOp() {
    assert_eq!(::std::mem::size_of::<Worker_FlagUpdateOp>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( Worker_FlagUpdateOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_FlagUpdateOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_FlagUpdateOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_FlagUpdateOp ) ) . name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_FlagUpdateOp ) ,
                "::" , stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_FlagUpdateOp ) ) . value as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_FlagUpdateOp ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for Worker_FlagUpdateOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a log message from the SDK. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_LogMessageOp {
    /** The severity of the log message; defined in the Worker_LogLevel enumeration. */
    pub level: u8,
    /** The message. */
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_LogMessageOp() {
    assert_eq!(::std::mem::size_of::<Worker_LogMessageOp>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( Worker_LogMessageOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_LogMessageOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_LogMessageOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LogMessageOp ) ) . level as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_LogMessageOp ) ,
                "::" , stringify ! ( level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LogMessageOp ) ) . message as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_LogMessageOp ) ,
                "::" , stringify ! ( message ) ));
}
impl Clone for Worker_LogMessageOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a set of built-in metrics reported by the SDK. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_MetricsOp {
    pub metrics: Worker_Metrics,
}
#[test]
fn bindgen_test_layout_Worker_MetricsOp() {
    assert_eq!(::std::mem::size_of::<Worker_MetricsOp>() , 40usize , concat !
               ( "Size of: " , stringify ! ( Worker_MetricsOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_MetricsOp>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( Worker_MetricsOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_MetricsOp ) ) . metrics as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_MetricsOp ) ,
                "::" , stringify ! ( metrics ) ));
}
impl Clone for Worker_MetricsOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a critical section boundary (enter or leave) operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CriticalSectionOp {
    /** Whether the protocol is entering a critical section (true) or leaving it (false). */
    pub in_critical_section: u8,
}
#[test]
fn bindgen_test_layout_Worker_CriticalSectionOp() {
    assert_eq!(::std::mem::size_of::<Worker_CriticalSectionOp>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_CriticalSectionOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_CriticalSectionOp>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_CriticalSectionOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CriticalSectionOp ) ) .
                in_critical_section as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Worker_CriticalSectionOp ) , "::" , stringify ! (
                in_critical_section ) ));
}
impl Clone for Worker_CriticalSectionOp {
    fn clone(&self) -> Self { *self }
}
/** Data for an AddEntity operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_AddEntityOp {
    /** The ID of the entity that was added to the worker's view of the simulation. */
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_AddEntityOp() {
    assert_eq!(::std::mem::size_of::<Worker_AddEntityOp>() , 8usize , concat !
               ( "Size of: " , stringify ! ( Worker_AddEntityOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_AddEntityOp>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_AddEntityOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AddEntityOp ) ) . entity_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_AddEntityOp ) ,
                "::" , stringify ! ( entity_id ) ));
}
impl Clone for Worker_AddEntityOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a RemoveEntity operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_RemoveEntityOp {
    /** The ID of the entity that was removed from the worker's view of the simulation. */
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_RemoveEntityOp() {
    assert_eq!(::std::mem::size_of::<Worker_RemoveEntityOp>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_RemoveEntityOp )
               ));
    assert_eq! (::std::mem::align_of::<Worker_RemoveEntityOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_RemoveEntityOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_RemoveEntityOp ) ) . entity_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_RemoveEntityOp )
                , "::" , stringify ! ( entity_id ) ));
}
impl Clone for Worker_RemoveEntityOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a ReserveEntityIdResponse operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ReserveEntityIdResponseOp {
    /** The ID of the reserve entity ID request for which there was a response. */
    pub request_id: Worker_RequestId,
    /** Status code of the response, using Worker_StatusCode. */
    pub status_code: u8,
    /** The error message. */
    pub message: *const ::std::os::raw::c_char,
    /**
   * If successful, newly allocated entity id which is guaranteed to be unused in the current
   * deployment.
   */
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_ReserveEntityIdResponseOp() {
    assert_eq!(::std::mem::size_of::<Worker_ReserveEntityIdResponseOp>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( Worker_ReserveEntityIdResponseOp )
               ));
    assert_eq! (::std::mem::align_of::<Worker_ReserveEntityIdResponseOp>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                Worker_ReserveEntityIdResponseOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdResponseOp ) ) .
                request_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdResponseOp ) , "::" , stringify ! (
                request_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdResponseOp ) ) .
                status_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdResponseOp ) , "::" , stringify ! (
                status_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdResponseOp ) ) .
                message as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdResponseOp ) , "::" , stringify ! (
                message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdResponseOp ) ) .
                entity_id as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdResponseOp ) , "::" , stringify ! (
                entity_id ) ));
}
impl Clone for Worker_ReserveEntityIdResponseOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a ReserveEntityIdsResponse operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ReserveEntityIdsResponseOp {
    /** The ID of the reserve entity ID request for which there was a response. */
    pub request_id: Worker_RequestId,
    /** Status code of the response, using Worker_StatusCode. */
    pub status_code: u8,
    /** The error message. */
    pub message: *const ::std::os::raw::c_char,
    /**
   * If successful, an ID which is the first in a contiguous range of newly allocated entity
   * IDs which are guaranteed to be unused in the current deployment.
   */
    pub first_entity_id: Worker_EntityId,
    /** If successful, the number of IDs reserved in the contiguous range, otherwise 0. */
    pub number_of_entity_ids: u32,
}
#[test]
fn bindgen_test_layout_Worker_ReserveEntityIdsResponseOp() {
    assert_eq!(::std::mem::size_of::<Worker_ReserveEntityIdsResponseOp>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( Worker_ReserveEntityIdsResponseOp )
               ));
    assert_eq! (::std::mem::align_of::<Worker_ReserveEntityIdsResponseOp>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                Worker_ReserveEntityIdsResponseOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdsResponseOp ) ) .
                request_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdsResponseOp ) , "::" , stringify ! (
                request_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdsResponseOp ) ) .
                status_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdsResponseOp ) , "::" , stringify ! (
                status_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdsResponseOp ) ) .
                message as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdsResponseOp ) , "::" , stringify ! (
                message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdsResponseOp ) ) .
                first_entity_id as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdsResponseOp ) , "::" , stringify ! (
                first_entity_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ReserveEntityIdsResponseOp ) ) .
                number_of_entity_ids as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ReserveEntityIdsResponseOp ) , "::" , stringify ! (
                number_of_entity_ids ) ));
}
impl Clone for Worker_ReserveEntityIdsResponseOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a CreateEntity operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CreateEntityResponseOp {
    /** The ID of the request for which there was a response. */
    pub request_id: Worker_RequestId,
    /** Status code of the response, using Worker_StatusCode. */
    pub status_code: u8,
    /** The error message. */
    pub message: *const ::std::os::raw::c_char,
    /** If successful, the entity ID of the newly created entity. */
    pub entity_id: Worker_EntityId,
}
#[test]
fn bindgen_test_layout_Worker_CreateEntityResponseOp() {
    assert_eq!(::std::mem::size_of::<Worker_CreateEntityResponseOp>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( Worker_CreateEntityResponseOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_CreateEntityResponseOp>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_CreateEntityResponseOp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CreateEntityResponseOp ) ) .
                request_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CreateEntityResponseOp ) , "::" , stringify ! (
                request_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CreateEntityResponseOp ) ) .
                status_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CreateEntityResponseOp ) , "::" , stringify ! (
                status_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CreateEntityResponseOp ) ) .
                message as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CreateEntityResponseOp ) , "::" , stringify ! ( message
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CreateEntityResponseOp ) ) .
                entity_id as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CreateEntityResponseOp ) , "::" , stringify ! (
                entity_id ) ));
}
impl Clone for Worker_CreateEntityResponseOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a DeleteEntity operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_DeleteEntityResponseOp {
    /** The ID of the delete entity request for which there was a command response. */
    pub request_id: Worker_RequestId,
    /** The ID of the target entity of this request. */
    pub entity_id: Worker_EntityId,
    /** Status code of the response, using Worker_StatusCode. */
    pub status_code: u8,
    /** The error message. */
    pub message: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_DeleteEntityResponseOp() {
    assert_eq!(::std::mem::size_of::<Worker_DeleteEntityResponseOp>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( Worker_DeleteEntityResponseOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_DeleteEntityResponseOp>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_DeleteEntityResponseOp
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeleteEntityResponseOp ) ) .
                request_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_DeleteEntityResponseOp ) , "::" , stringify ! (
                request_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeleteEntityResponseOp ) ) .
                entity_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_DeleteEntityResponseOp ) , "::" , stringify ! (
                entity_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeleteEntityResponseOp ) ) .
                status_code as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_DeleteEntityResponseOp ) , "::" , stringify ! (
                status_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeleteEntityResponseOp ) ) .
                message as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_DeleteEntityResponseOp ) , "::" , stringify ! ( message
                ) ));
}
impl Clone for Worker_DeleteEntityResponseOp {
    fn clone(&self) -> Self { *self }
}
/** A response indicating the result of an entity query request. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_EntityQueryResponseOp {
    /** The ID of the entity query request for which there was a response. */
    pub request_id: Worker_RequestId,
    /** Status code of the response, using Worker_StatusCode. */
    pub status_code: u8,
    /** The error message. */
    pub message: *const ::std::os::raw::c_char,
    /**
   * Number of entities in the result set. Reused to indicate the result itself for CountResultType
   * queries.
   */
    pub result_count: u32,
    /**
   * Array of entities in the result set. Will be NULL if the query was a count query. Snapshot data
   * in the result is deserialized with the corresponding vtable Deserialize function and freed with
   * the vtable Free function when the OpList is destroyed.
   */
    pub results: *const Worker_Entity,
}
#[test]
fn bindgen_test_layout_Worker_EntityQueryResponseOp() {
    assert_eq!(::std::mem::size_of::<Worker_EntityQueryResponseOp>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( Worker_EntityQueryResponseOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_EntityQueryResponseOp>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_EntityQueryResponseOp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQueryResponseOp ) ) .
                request_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_EntityQueryResponseOp ) , "::" , stringify ! (
                request_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQueryResponseOp ) ) .
                status_code as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_EntityQueryResponseOp ) , "::" , stringify ! (
                status_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQueryResponseOp ) ) .
                message as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_EntityQueryResponseOp ) , "::" , stringify ! ( message
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQueryResponseOp ) ) .
                result_count as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_EntityQueryResponseOp ) , "::" , stringify ! (
                result_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_EntityQueryResponseOp ) ) .
                results as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_EntityQueryResponseOp ) , "::" , stringify ! ( results
                ) ));
}
impl Clone for Worker_EntityQueryResponseOp {
    fn clone(&self) -> Self { *self }
}
/** Data for an AddComponent operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_AddComponentOp {
    /** The ID of the entity for which a component was added. */
    pub entity_id: Worker_EntityId,
    /**
   * The initial data for the new component. Deserialized with the corresponding vtable Deserialize
   * function and freed with the vtable Free function when the OpList is destroyed.
   */
    pub data: Worker_ComponentData,
}
#[test]
fn bindgen_test_layout_Worker_AddComponentOp() {
    assert_eq!(::std::mem::size_of::<Worker_AddComponentOp>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_AddComponentOp )
               ));
    assert_eq! (::std::mem::align_of::<Worker_AddComponentOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_AddComponentOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AddComponentOp ) ) . entity_id as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_AddComponentOp )
                , "::" , stringify ! ( entity_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AddComponentOp ) ) . data as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_AddComponentOp )
                , "::" , stringify ! ( data ) ));
}
impl Clone for Worker_AddComponentOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a RemoveComponent operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_RemoveComponentOp {
    /** The ID of the entity for which a component was removed. */
    pub entity_id: Worker_EntityId,
    /** The ID of the component that was removed. */
    pub component_id: Worker_ComponentId,
}
#[test]
fn bindgen_test_layout_Worker_RemoveComponentOp() {
    assert_eq!(::std::mem::size_of::<Worker_RemoveComponentOp>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_RemoveComponentOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_RemoveComponentOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_RemoveComponentOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_RemoveComponentOp ) ) . entity_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_RemoveComponentOp ) , "::" , stringify ! ( entity_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_RemoveComponentOp ) ) .
                component_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_RemoveComponentOp ) , "::" , stringify ! ( component_id
                ) ));
}
impl Clone for Worker_RemoveComponentOp {
    fn clone(&self) -> Self { *self }
}
/** Data for an AuthorityChange operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_AuthorityChangeOp {
    /** The ID of the entity for which there was an authority change. */
    pub entity_id: Worker_EntityId,
    /** The ID of the component over which the worker's authority has changed. */
    pub component_id: Worker_ComponentId,
    /** The authority state of the component, using the Worker_Authority enumeration. */
    pub authority: u8,
}
#[test]
fn bindgen_test_layout_Worker_AuthorityChangeOp() {
    assert_eq!(::std::mem::size_of::<Worker_AuthorityChangeOp>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_AuthorityChangeOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_AuthorityChangeOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_AuthorityChangeOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AuthorityChangeOp ) ) . entity_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_AuthorityChangeOp ) , "::" , stringify ! ( entity_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AuthorityChangeOp ) ) .
                component_id as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_AuthorityChangeOp ) , "::" , stringify ! ( component_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_AuthorityChangeOp ) ) . authority
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_AuthorityChangeOp ) , "::" , stringify ! ( authority )
                ));
}
impl Clone for Worker_AuthorityChangeOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a ComponentUpdate operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ComponentUpdateOp {
    /** The ID of the entity for which there was a component update. */
    pub entity_id: Worker_EntityId,
    /**
   * The new component data for the updated entity. Deserialized with the corresponding vtable
   * Deserialize function and freed with the vtable Free function when the OpList is destroyed.
   */
    pub update: Worker_ComponentUpdate,
}
#[test]
fn bindgen_test_layout_Worker_ComponentUpdateOp() {
    assert_eq!(::std::mem::size_of::<Worker_ComponentUpdateOp>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_ComponentUpdateOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_ComponentUpdateOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_ComponentUpdateOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentUpdateOp ) ) . entity_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ComponentUpdateOp ) , "::" , stringify ! ( entity_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ComponentUpdateOp ) ) . update as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ComponentUpdateOp ) , "::" , stringify ! ( update ) ));
}
impl Clone for Worker_ComponentUpdateOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a CommandRequest operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CommandRequestOp {
    /** The incoming command request ID. */
    pub request_id: Worker_RequestId,
    /** The ID of the entity for which there was a command request. */
    pub entity_id: Worker_EntityId,
    /** Upper bound on request timeout provided by the platform. */
    pub timeout_millis: u32,
    /** The ID of the worker that sent the request. */
    pub caller_worker_id: *const ::std::os::raw::c_char,
    /** The attributes of the worker that sent the request. */
    pub caller_attribute_set: Worker_WorkerAttributes,
    /**
   * The command request data. Deserialized with the corresponding vtable Deserialize function and
   * freed with the vtable Free function when the OpList is destroyed.
   */
    pub request: Worker_CommandRequest,
}
#[test]
fn bindgen_test_layout_Worker_CommandRequestOp() {
    assert_eq!(::std::mem::size_of::<Worker_CommandRequestOp>() , 80usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_CommandRequestOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_CommandRequestOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_CommandRequestOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequestOp ) ) . request_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequestOp
                ) , "::" , stringify ! ( request_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequestOp ) ) . entity_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequestOp
                ) , "::" , stringify ! ( entity_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequestOp ) ) .
                timeout_millis as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequestOp
                ) , "::" , stringify ! ( timeout_millis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequestOp ) ) .
                caller_worker_id as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( Worker_CommandRequestOp
                ) , "::" , stringify ! ( caller_worker_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequestOp ) ) .
                caller_attribute_set as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequestOp
                ) , "::" , stringify ! ( caller_attribute_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandRequestOp ) ) . request as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_CommandRequestOp
                ) , "::" , stringify ! ( request ) ));
}
impl Clone for Worker_CommandRequestOp {
    fn clone(&self) -> Self { *self }
}
/** Data for a CommandResponse operation. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CommandResponseOp {
    /** The ID of the command request for which there was a command response. */
    pub request_id: Worker_RequestId,
    /** The ID of the entity originally targeted by the command request. */
    pub entity_id: Worker_EntityId,
    /** Status code of the response, using Worker_StatusCode. */
    pub status_code: u8,
    /** The error message. */
    pub message: *const ::std::os::raw::c_char,
    /**
   * The command response data. Deserialized with the corresponding vtable Deserialize function and
   * freed with the vtable Free function when the OpList is destroyed.
   */
    pub response: Worker_CommandResponse,
    /** The command ID given to Worker_Connection_SendCommandRequest. */
    pub command_id: u32,
}
#[test]
fn bindgen_test_layout_Worker_CommandResponseOp() {
    assert_eq!(::std::mem::size_of::<Worker_CommandResponseOp>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_CommandResponseOp ) ));
    assert_eq! (::std::mem::align_of::<Worker_CommandResponseOp>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_CommandResponseOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponseOp ) ) . request_id
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandResponseOp ) , "::" , stringify ! ( request_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponseOp ) ) . entity_id
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandResponseOp ) , "::" , stringify ! ( entity_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponseOp ) ) .
                status_code as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandResponseOp ) , "::" , stringify ! ( status_code
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponseOp ) ) . message as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandResponseOp ) , "::" , stringify ! ( message )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponseOp ) ) . response
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandResponseOp ) , "::" , stringify ! ( response )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandResponseOp ) ) . command_id
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandResponseOp ) , "::" , stringify ! ( command_id )
                ));
}
impl Clone for Worker_CommandResponseOp {
    fn clone(&self) -> Self { *self }
}
pub mod Worker_OpType {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_OP_TYPE_DISCONNECT: Type = 1;
    pub const WORKER_OP_TYPE_FLAG_UPDATE: Type = 2;
    pub const WORKER_OP_TYPE_LOG_MESSAGE: Type = 3;
    pub const WORKER_OP_TYPE_METRICS: Type = 4;
    pub const WORKER_OP_TYPE_CRITICAL_SECTION: Type = 5;
    pub const WORKER_OP_TYPE_ADD_ENTITY: Type = 6;
    pub const WORKER_OP_TYPE_REMOVE_ENTITY: Type = 7;
    pub const WORKER_OP_TYPE_RESERVE_ENTITY_ID_RESPONSE: Type = 8;
    pub const WORKER_OP_TYPE_RESERVE_ENTITY_IDS_RESPONSE: Type = 9;
    pub const WORKER_OP_TYPE_CREATE_ENTITY_RESPONSE: Type = 10;
    pub const WORKER_OP_TYPE_DELETE_ENTITY_RESPONSE: Type = 11;
    pub const WORKER_OP_TYPE_ENTITY_QUERY_RESPONSE: Type = 12;
    pub const WORKER_OP_TYPE_ADD_COMPONENT: Type = 13;
    pub const WORKER_OP_TYPE_REMOVE_COMPONENT: Type = 14;
    pub const WORKER_OP_TYPE_AUTHORITY_CHANGE: Type = 15;
    pub const WORKER_OP_TYPE_COMPONENT_UPDATE: Type = 16;
    pub const WORKER_OP_TYPE_COMMAND_REQUEST: Type = 17;
    pub const WORKER_OP_TYPE_COMMAND_RESPONSE: Type = 18;
}
/** Data for a single op contained within an op list. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Op {
    /** The type of this op, defined in Worker_OpType. */
    pub op_type: u8,
    pub __bindgen_anon_1: Worker_Op__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Op__bindgen_ty_1 {
    pub disconnect: __BindgenUnionField<Worker_DisconnectOp>,
    pub flag_update: __BindgenUnionField<Worker_FlagUpdateOp>,
    pub log_message: __BindgenUnionField<Worker_LogMessageOp>,
    pub metrics: __BindgenUnionField<Worker_MetricsOp>,
    pub critical_section: __BindgenUnionField<Worker_CriticalSectionOp>,
    pub add_entity: __BindgenUnionField<Worker_AddEntityOp>,
    pub remove_entity: __BindgenUnionField<Worker_RemoveEntityOp>,
    pub reserve_entity_id_response: __BindgenUnionField<Worker_ReserveEntityIdResponseOp>,
    pub reserve_entity_ids_response: __BindgenUnionField<Worker_ReserveEntityIdsResponseOp>,
    pub create_entity_response: __BindgenUnionField<Worker_CreateEntityResponseOp>,
    pub delete_entity_response: __BindgenUnionField<Worker_DeleteEntityResponseOp>,
    pub entity_query_response: __BindgenUnionField<Worker_EntityQueryResponseOp>,
    pub add_component: __BindgenUnionField<Worker_AddComponentOp>,
    pub remove_component: __BindgenUnionField<Worker_RemoveComponentOp>,
    pub authority_change: __BindgenUnionField<Worker_AuthorityChangeOp>,
    pub component_update: __BindgenUnionField<Worker_ComponentUpdateOp>,
    pub command_request: __BindgenUnionField<Worker_CommandRequestOp>,
    pub command_response: __BindgenUnionField<Worker_CommandResponseOp>,
    pub bindgen_union_field: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_Worker_Op__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<Worker_Op__bindgen_ty_1>() , 80usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_Op__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<Worker_Op__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_Op__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) . disconnect
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( disconnect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) . flag_update
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( flag_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) . log_message
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( log_message ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) . metrics as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( metrics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                critical_section as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( critical_section ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) . add_entity
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( add_entity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                remove_entity as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( remove_entity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                reserve_entity_id_response as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( reserve_entity_id_response ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                reserve_entity_ids_response as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( reserve_entity_ids_response ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                create_entity_response as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( create_entity_response ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                delete_entity_response as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( delete_entity_response ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                entity_query_response as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( entity_query_response ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                add_component as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( add_component ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                remove_component as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( remove_component ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                authority_change as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( authority_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                component_update as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( component_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                command_request as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( command_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op__bindgen_ty_1 ) ) .
                command_response as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op__bindgen_ty_1
                ) , "::" , stringify ! ( command_response ) ));
}
impl Clone for Worker_Op__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_Worker_Op() {
    assert_eq!(::std::mem::size_of::<Worker_Op>() , 88usize , concat ! (
               "Size of: " , stringify ! ( Worker_Op ) ));
    assert_eq! (::std::mem::align_of::<Worker_Op>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_Op ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Op ) ) . op_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Op ) , "::" ,
                stringify ! ( op_type ) ));
}
impl Clone for Worker_Op {
    fn clone(&self) -> Self { *self }
}
/** Parameters for configuring a RakNet connection. Used by Worker_NetworkParameters. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_RakNetNetworkParameters {
    /** Time (in milliseconds) that RakNet should use for its heartbeat protocol. */
    pub heartbeat_timeout_millis: u32,
}
#[test]
fn bindgen_test_layout_Worker_RakNetNetworkParameters() {
    assert_eq!(::std::mem::size_of::<Worker_RakNetNetworkParameters>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( Worker_RakNetNetworkParameters )
               ));
    assert_eq! (::std::mem::align_of::<Worker_RakNetNetworkParameters>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( Worker_RakNetNetworkParameters
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_RakNetNetworkParameters ) ) .
                heartbeat_timeout_millis as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_RakNetNetworkParameters ) , "::" , stringify ! (
                heartbeat_timeout_millis ) ));
}
impl Clone for Worker_RakNetNetworkParameters {
    fn clone(&self) -> Self { *self }
}
/** Parameters for configuring a TCP connection. Used by Worker_NetworkParameters. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_TcpNetworkParameters {
    /** The number of multiplexed TCP connections to use. */
    pub multiplex_level: u8,
    /** Size in bytes of the TCP send buffer. */
    pub send_buffer_size: u32,
    /** Size in bytes of the TCP receive buffer. */
    pub receive_buffer_size: u32,
    /** Whether to enable TCP_NODELAY. */
    pub no_delay: u8,
}
#[test]
fn bindgen_test_layout_Worker_TcpNetworkParameters() {
    assert_eq!(::std::mem::size_of::<Worker_TcpNetworkParameters>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( Worker_TcpNetworkParameters ) ));
    assert_eq! (::std::mem::align_of::<Worker_TcpNetworkParameters>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( Worker_TcpNetworkParameters )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_TcpNetworkParameters ) ) .
                multiplex_level as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_TcpNetworkParameters ) , "::" , stringify ! (
                multiplex_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_TcpNetworkParameters ) ) .
                send_buffer_size as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_TcpNetworkParameters ) , "::" , stringify ! (
                send_buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_TcpNetworkParameters ) ) .
                receive_buffer_size as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Worker_TcpNetworkParameters ) , "::" , stringify ! (
                receive_buffer_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_TcpNetworkParameters ) ) .
                no_delay as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_TcpNetworkParameters ) , "::" , stringify ! ( no_delay
                ) ));
}
impl Clone for Worker_TcpNetworkParameters {
    fn clone(&self) -> Self { *self }
}
pub mod Worker_NetworkConnectionType {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_NETWORK_CONNECTION_TYPE_TCP: Type = 0;
    pub const WORKER_NETWORK_CONNECTION_TYPE_RAKNET: Type = 1;
}
/** Parameters for configuring the network connection. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_NetworkParameters {
    /**
   * Set this flag to non-zero to connect to SpatialOS using the externally-visible IP address. This
   * flag must be set when connecting externally (i.e. from outside the cloud) to a cloud
   * deployment.
   */
    pub use_external_ip: u8,
    /**
   * Type of network connection to use when connecting to SpatialOS, defined in
   * Worker_NetworkConnectionType.
   */
    pub connection_type: u8,
    /** Parameters used if the WORKER_NETWORK_RAKNET flag is set. */
    pub raknet: Worker_RakNetNetworkParameters,
    /** Parameters used if the WORKER_NETWORK_TCP flag is set. */
    pub tcp: Worker_TcpNetworkParameters,
    /** Timeout for the connection to SpatialOS to be established. */
    pub connection_timeout_millis: u64,
}
#[test]
fn bindgen_test_layout_Worker_NetworkParameters() {
    assert_eq!(::std::mem::size_of::<Worker_NetworkParameters>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_NetworkParameters ) ));
    assert_eq! (::std::mem::align_of::<Worker_NetworkParameters>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_NetworkParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_NetworkParameters ) ) .
                use_external_ip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_NetworkParameters ) , "::" , stringify ! (
                use_external_ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_NetworkParameters ) ) .
                connection_type as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_NetworkParameters ) , "::" , stringify ! (
                connection_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_NetworkParameters ) ) . raknet as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_NetworkParameters ) , "::" , stringify ! ( raknet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_NetworkParameters ) ) . tcp as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_NetworkParameters ) , "::" , stringify ! ( tcp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_NetworkParameters ) ) .
                connection_timeout_millis as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_NetworkParameters ) , "::" , stringify ! (
                connection_timeout_millis ) ));
}
impl Clone for Worker_NetworkParameters {
    fn clone(&self) -> Self { *self }
}
/**
 * Tuning parameters for configuring protocol logging in the SDK. Used by
 * Worker_ConnectionParameters.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ProtocolLoggingParameters {
    /** Log file names are prefixed with this prefix, are numbered, and have the extension .log. */
    pub log_prefix: *const ::std::os::raw::c_char,
    /**
   * Maximum number of log files to keep. Note that logs from any previous protocol logging
   * sessions will be overwritten.
   */
    pub max_log_files: u32,
    /** Once the size of a log file reaches this size, a new log file is created. */
    pub max_log_file_size_bytes: u32,
}
#[test]
fn bindgen_test_layout_Worker_ProtocolLoggingParameters() {
    assert_eq!(::std::mem::size_of::<Worker_ProtocolLoggingParameters>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( Worker_ProtocolLoggingParameters )
               ));
    assert_eq! (::std::mem::align_of::<Worker_ProtocolLoggingParameters>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                Worker_ProtocolLoggingParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ProtocolLoggingParameters ) ) .
                log_prefix as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ProtocolLoggingParameters ) , "::" , stringify ! (
                log_prefix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ProtocolLoggingParameters ) ) .
                max_log_files as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ProtocolLoggingParameters ) , "::" , stringify ! (
                max_log_files ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ProtocolLoggingParameters ) ) .
                max_log_file_size_bytes as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ProtocolLoggingParameters ) , "::" , stringify ! (
                max_log_file_size_bytes ) ));
}
impl Clone for Worker_ProtocolLoggingParameters {
    fn clone(&self) -> Self { *self }
}
/** Parameters for creating a Worker_Connection and connecting to SpatialOS. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_ConnectionParameters {
    /** Worker type (platform). */
    pub worker_type: *const ::std::os::raw::c_char,
    /** Network parameters. */
    pub network: Worker_NetworkParameters,
    /**
   * Number of messages that can be stored on the send queue. When the send queue is full, calls to
   * Worker_Connection_Send functions can block.
   */
    pub send_queue_capacity: u32,
    /**
   * Number of messages that can be stored on the receive queue. When the receive queue is full,
   * SpatialOS can apply QoS and drop messages to the worker.
   */
    pub receive_queue_capacity: u32,
    /**
   * Number of messages logged by the SDK that can be stored in the log message queue. When the log
   * message queue is full, messages logged by the SDK can be dropped.
   */
    pub log_message_queue_capacity: u32,
    /**
   * The Connection tracks several internal metrics, such as send and receive queue statistics. This
   * parameter controls how frequently the Connection will return a MetricsOp reporting its built-in
   * metrics. If set to zero, this functionality is disabled.
   */
    pub built_in_metrics_report_period_millis: u32,
    /** Parameters for configuring protocol parameters. */
    pub protocol_logging: Worker_ProtocolLoggingParameters,
    /** Whether to enable protocol logging at startup. */
    pub enable_protocol_logging_at_startup: u8,
    /** Number of component vtables. */
    pub component_vtable_count: u32,
    /** Component vtable for each component that the connection will deal with. */
    pub component_vtables: *const Worker_ComponentVtable,
    /** Default vtable used when a component is not registered. Only used if not NULL. */
    pub default_component_vtable: *const Worker_ComponentVtable,
}
#[test]
fn bindgen_test_layout_Worker_ConnectionParameters() {
    assert_eq!(::std::mem::size_of::<Worker_ConnectionParameters>() , 96usize
               , concat ! (
               "Size of: " , stringify ! ( Worker_ConnectionParameters ) ));
    assert_eq! (::std::mem::align_of::<Worker_ConnectionParameters>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( Worker_ConnectionParameters )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                worker_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                worker_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) . network
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! ( network )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                send_queue_capacity as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                send_queue_capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                receive_queue_capacity as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                receive_queue_capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                log_message_queue_capacity as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                log_message_queue_capacity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                built_in_metrics_report_period_millis as * const _ as usize }
                , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                built_in_metrics_report_period_millis ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                protocol_logging as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                protocol_logging ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                enable_protocol_logging_at_startup as * const _ as usize } ,
                72usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                enable_protocol_logging_at_startup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                component_vtable_count as * const _ as usize } , 76usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                component_vtable_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                component_vtables as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                component_vtables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_ConnectionParameters ) ) .
                default_component_vtable as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_ConnectionParameters ) , "::" , stringify ! (
                default_component_vtable ) ));
}
impl Clone for Worker_ConnectionParameters {
    fn clone(&self) -> Self { *self }
}
/** Parameters for authenticating using a SpatialOS login token. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_LoginTokenCredentials {
    /** The token would typically be provided on the command-line by the SpatialOS launcher. */
    pub token: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_LoginTokenCredentials() {
    assert_eq!(::std::mem::size_of::<Worker_LoginTokenCredentials>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( Worker_LoginTokenCredentials ) ));
    assert_eq! (::std::mem::align_of::<Worker_LoginTokenCredentials>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( Worker_LoginTokenCredentials )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LoginTokenCredentials ) ) . token
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LoginTokenCredentials ) , "::" , stringify ! ( token )
                ));
}
impl Clone for Worker_LoginTokenCredentials {
    fn clone(&self) -> Self { *self }
}
/** Parameters for authenticating using Steam credentials. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_SteamCredentials {
    /**
   * Steam ticket for the steam app ID and publisher key corresponding to the project name specified
   * in the Worker_LocatorParameters. Typically obtained from the steam APIs.
   */
    pub ticket: *const ::std::os::raw::c_char,
    /**
   * Deployment tag to request access for. If non-empty, must match the following regex:
   * [A-Za-z0-9][A-Za-z0-9_]*
   */
    pub deployment_tag: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_SteamCredentials() {
    assert_eq!(::std::mem::size_of::<Worker_SteamCredentials>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_SteamCredentials ) ));
    assert_eq! (::std::mem::align_of::<Worker_SteamCredentials>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_SteamCredentials ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SteamCredentials ) ) . ticket as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_SteamCredentials
                ) , "::" , stringify ! ( ticket ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SteamCredentials ) ) .
                deployment_tag as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_SteamCredentials
                ) , "::" , stringify ! ( deployment_tag ) ));
}
impl Clone for Worker_SteamCredentials {
    fn clone(&self) -> Self { *self }
}
pub mod Worker_LocatorCredentialsTypes {
    pub type Type = ::std::os::raw::c_uint;
    pub const WORKER_LOCATOR_LOGIN_TOKEN_CREDENTIALS: Type = 1;
    pub const WORKER_LOCATOR_STEAM_CREDENTIALS: Type = 2;
}
/** Parameters for authenticating and logging in to a SpatialOS deployment. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_LocatorParameters {
    /** The name of the SpatialOS project. */
    pub project_name: *const ::std::os::raw::c_char,
    /**
   * Type of credentials to use when authenticating via the Locator, defined in
   * Worker_LocatorCredentialsTypes
   */
    pub credentials_type: u8,
    /** Parameters used if the WORKER_LOGIN_TOKEN_CREDENTIALS flag is set. */
    pub login_token: Worker_LoginTokenCredentials,
    /** Parameters used if the WORKER_STEAM_CREDENTIALS flag is set. */
    pub steam: Worker_SteamCredentials,
    /** Parameters for configuring logging. */
    pub logging: Worker_ProtocolLoggingParameters,
    /** Whether to enable logging for the Locator flow. */
    pub enable_logging: u8,
}
#[test]
fn bindgen_test_layout_Worker_LocatorParameters() {
    assert_eq!(::std::mem::size_of::<Worker_LocatorParameters>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_LocatorParameters ) ));
    assert_eq! (::std::mem::align_of::<Worker_LocatorParameters>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_LocatorParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LocatorParameters ) ) .
                project_name as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LocatorParameters ) , "::" , stringify ! ( project_name
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LocatorParameters ) ) .
                credentials_type as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LocatorParameters ) , "::" , stringify ! (
                credentials_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LocatorParameters ) ) .
                login_token as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LocatorParameters ) , "::" , stringify ! ( login_token
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LocatorParameters ) ) . steam as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LocatorParameters ) , "::" , stringify ! ( steam ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LocatorParameters ) ) . logging as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LocatorParameters ) , "::" , stringify ! ( logging )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_LocatorParameters ) ) .
                enable_logging as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                Worker_LocatorParameters ) , "::" , stringify ! (
                enable_logging ) ));
}
impl Clone for Worker_LocatorParameters {
    fn clone(&self) -> Self { *self }
}
/** Details of a specific deployment obtained via Worker_Locator_GetDeploymentListAsync. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_Deployment {
    /** Name of the deployment. */
    pub deployment_name: *const ::std::os::raw::c_char,
    /** The name of the assembly used by this deployment. */
    pub assembly_name: *const ::std::os::raw::c_char,
    /** Description of the deployment. */
    pub description: *const ::std::os::raw::c_char,
    /** Number of users currently connected to the deployment. */
    pub users_connected: u32,
    /** Total user capacity of the deployment. */
    pub users_capacity: u32,
}
#[test]
fn bindgen_test_layout_Worker_Deployment() {
    assert_eq!(::std::mem::size_of::<Worker_Deployment>() , 32usize , concat !
               ( "Size of: " , stringify ! ( Worker_Deployment ) ));
    assert_eq! (::std::mem::align_of::<Worker_Deployment>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_Deployment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Deployment ) ) . deployment_name
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Deployment ) ,
                "::" , stringify ! ( deployment_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Deployment ) ) . assembly_name as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Deployment ) ,
                "::" , stringify ! ( assembly_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Deployment ) ) . description as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Deployment ) ,
                "::" , stringify ! ( description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Deployment ) ) . users_connected
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Deployment ) ,
                "::" , stringify ! ( users_connected ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_Deployment ) ) . users_capacity as
                * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_Deployment ) ,
                "::" , stringify ! ( users_capacity ) ));
}
impl Clone for Worker_Deployment {
    fn clone(&self) -> Self { *self }
}
/** A deployment list obtained via Worker_Locator_GetDeploymentListAsync. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_DeploymentList {
    /** Number of deployments. */
    pub deployment_count: u32,
    /** Array of deployments. */
    pub deployments: *mut Worker_Deployment,
    /** Will be non-NULL if an error occurred. */
    pub error: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_DeploymentList() {
    assert_eq!(::std::mem::size_of::<Worker_DeploymentList>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( Worker_DeploymentList )
               ));
    assert_eq! (::std::mem::align_of::<Worker_DeploymentList>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_DeploymentList ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeploymentList ) ) .
                deployment_count as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_DeploymentList )
                , "::" , stringify ! ( deployment_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeploymentList ) ) . deployments
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_DeploymentList )
                , "::" , stringify ! ( deployments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_DeploymentList ) ) . error as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_DeploymentList )
                , "::" , stringify ! ( error ) ));
}
impl Clone for Worker_DeploymentList {
    fn clone(&self) -> Self { *self }
}
/**
 * A queue status update when connecting to a deployment via Worker_Locator_ConnectAsync.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_QueueStatus {
    /** Position in the queue. Decreases as we advance to the front of the queue. */
    pub position_in_queue: u32,
    /** Will be non-NULL if an error occurred. */
    pub error: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Worker_QueueStatus() {
    assert_eq!(::std::mem::size_of::<Worker_QueueStatus>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( Worker_QueueStatus ) ));
    assert_eq! (::std::mem::align_of::<Worker_QueueStatus>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( Worker_QueueStatus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_QueueStatus ) ) .
                position_in_queue as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( Worker_QueueStatus ) ,
                "::" , stringify ! ( position_in_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_QueueStatus ) ) . error as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( Worker_QueueStatus ) ,
                "::" , stringify ! ( error ) ));
}
impl Clone for Worker_QueueStatus {
    fn clone(&self) -> Self { *self }
}
/** Command parameters. Used to modify the behaviour of a command request. */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_CommandParameters {
    /**
   * Allow command requests to bypass the bridge when this worker is authoritative over the target
   * entity-component.
   */
    pub allow_short_circuit: u8,
}
#[test]
fn bindgen_test_layout_Worker_CommandParameters() {
    assert_eq!(::std::mem::size_of::<Worker_CommandParameters>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_CommandParameters ) ));
    assert_eq! (::std::mem::align_of::<Worker_CommandParameters>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_CommandParameters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_CommandParameters ) ) .
                allow_short_circuit as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                Worker_CommandParameters ) , "::" , stringify ! (
                allow_short_circuit ) ));
}
impl Clone for Worker_CommandParameters {
    fn clone(&self) -> Self { *self }
}
/** Locator callback typedef. */
pub type Worker_DeploymentListCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void,
                                               deployment_list:
                                                   *const Worker_DeploymentList)>;
/** Locator callback typedef. */
pub type Worker_QueueStatusCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void,
                                               queue_status:
                                                   *const Worker_QueueStatus)
                              -> u8>;
/** Worker flags callback typedef. */
pub type Worker_GetFlagCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data:
                                                   *mut ::std::os::raw::c_void,
                                               value:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    /**
 * Returns a new Worker_ConnectionParameters with default values set.
 */
    pub fn Worker_DefaultConnectionParameters()
     -> Worker_ConnectionParameters;
}
extern "C" {
    /**
 * Creates a client which can be used to connect to a SpatialOS deployment via a locator service.
 * This is the standard flow used to connect a local worker to a cloud deployment.
 *
 * The hostname would typically be either "locator.improbable.io" (for production) or
 * "locator-staging.improbable.io" (for staging).
 */
    pub fn Worker_Locator_Create(hostname: *const ::std::os::raw::c_char,
                                 params: *const Worker_LocatorParameters)
     -> *mut Worker_Locator;
}
extern "C" {
    /** Frees resources for a Worker_Locator created with Worker_Locator_Create. */
    pub fn Worker_Locator_Destroy(locator: *mut Worker_Locator);
}
extern "C" {
    /**
 * Queries the current list of deployments for the project given in the
 * Worker_LocatorParameters.
 */
    pub fn Worker_Locator_GetDeploymentListAsync(locator:
                                                     *const Worker_Locator)
     -> *mut Worker_DeploymentListFuture;
}
extern "C" {
    /**
 * Connects to a specific deployment. The deployment name should be obtained by calling
 * Worker_Locator_GetDeploymentListAsync. The callback should return zero to cancel queuing,
 * or non-zero to continue queueing.
 *
 * Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection
 * by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no
 * longer needed by using Worker_ConnectionFuture_Destroy.
 */
    pub fn Worker_Locator_ConnectAsync(locator: *const Worker_Locator,
                                       deployment_name:
                                           *const ::std::os::raw::c_char,
                                       params:
                                           *const Worker_ConnectionParameters,
                                       data: *mut ::std::os::raw::c_void,
                                       callback: Worker_QueueStatusCallback)
     -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /**
 * Connect to a SpatialOS deployment via a receptionist. This is the flow used to connect a managed
 * worker running in the cloud alongside the deployment, and also to connect any local worker to a
 * (local or remote) deployment via a locally-running receptionist.
 *
 * The hostname and port would typically be provided by SpatialOS on the command-line, if this is a
 * managed worker on the cloud, or otherwise be predetermined (e.g. localhost:7777 for the default
 * receptionist of a locally-running deployment).
 *
 * Returns a Worker_ConnectionFuture that can be used to obtain a Worker_Connection
 * by using Worker_ConnectionFuture_Get. Caller is responsible for destroying it when no
 * longer needed by using Worker_ConnectionFuture_Destroy.
 */
    pub fn Worker_ConnectAsync(hostname: *const ::std::os::raw::c_char,
                               port: u16,
                               worker_id: *const ::std::os::raw::c_char,
                               params: *const Worker_ConnectionParameters)
     -> *mut Worker_ConnectionFuture;
}
extern "C" {
    /** Destroys a Worker_DeploymentListFuture. Blocks until the future has completed. */
    pub fn Worker_DeploymentListFuture_Destroy(future:
                                                   *mut Worker_DeploymentListFuture);
}
extern "C" {
    /**
 * Gets the result of a Worker_DeploymentListFuture, waiting for up to *timeout_millis to
 * become available (or forever if timeout_millis is NULL).
 *
 * It is an error to call this method again once it has succeeded (e.g. not timed out) once.
 */
    pub fn Worker_DeploymentListFuture_Get(future:
                                               *mut Worker_DeploymentListFuture,
                                           timeout_millis: *const u32,
                                           data: *mut ::std::os::raw::c_void,
                                           callback:
                                               Worker_DeploymentListCallback);
}
extern "C" {
    /** Destroys a Worker_ConnectionFuture. Blocks until the future has completed. */
    pub fn Worker_ConnectionFuture_Destroy(future:
                                               *mut Worker_ConnectionFuture);
}
extern "C" {
    /**
 * Gets the result of a Worker_ConnectionFuture, waiting for up to *timeout_millis to
 * become available (or forever if timeout_millis is NULL). It returns NULL in case of a timeout.
 *
 * It is an error to call this method again once it has succeeded (e.g. not timed out) once.
 */
    pub fn Worker_ConnectionFuture_Get(future: *mut Worker_ConnectionFuture,
                                       timeout_millis: *const u32)
     -> *mut Worker_Connection;
}
extern "C" {
    /**
 * Frees resources for a Worker_Connection created with Worker_ConnectAsync or
 * Worker_Locator_ConnectAsync.
 */
    pub fn Worker_Connection_Destroy(connection: *mut Worker_Connection);
}
extern "C" {
    /** Sends a log message from the worker to SpatialOS. */
    pub fn Worker_Connection_SendLogMessage(connection:
                                                *mut Worker_Connection,
                                            log_message:
                                                *const Worker_LogMessage);
}
extern "C" {
    /** Sends metrics data for the worker to SpatialOS. */
    pub fn Worker_Connection_SendMetrics(connection: *mut Worker_Connection,
                                         metrics: *const Worker_Metrics);
}
extern "C" {
    /** Requests SpatialOS to reserve an entity ID. */
    pub fn Worker_Connection_SendReserveEntityIdRequest(connection:
                                                            *mut Worker_Connection,
                                                        timeout_millis:
                                                            *const u32)
     -> Worker_RequestId;
}
extern "C" {
    /** Requests SpatialOS to reserve multiple entity IDs. */
    pub fn Worker_Connection_SendReserveEntityIdsRequest(connection:
                                                             *mut Worker_Connection,
                                                         number_of_entity_ids:
                                                             u32,
                                                         timeout_millis:
                                                             *const u32)
     -> Worker_RequestId;
}
extern "C" {
    /**
 * Requests SpatialOS to create an entity. The entity data is serialized immediately using the
 * corresponding vtable Serialize function; no copy is made or ownership transferred.
 */
    pub fn Worker_Connection_SendCreateEntityRequest(connection:
                                                         *mut Worker_Connection,
                                                     component_count: u32,
                                                     components:
                                                         *const Worker_ComponentData,
                                                     entity_id:
                                                         *const Worker_EntityId,
                                                     timeout_millis:
                                                         *const u32)
     -> Worker_RequestId;
}
extern "C" {
    /** Requests SpatialOS to delete an entity. */
    pub fn Worker_Connection_SendDeleteEntityRequest(connection:
                                                         *mut Worker_Connection,
                                                     entity_id:
                                                         Worker_EntityId,
                                                     timeout_millis:
                                                         *const u32)
     -> Worker_RequestId;
}
extern "C" {
    /** Queries SpatialOS for entity data. */
    pub fn Worker_Connection_SendEntityQueryRequest(connection:
                                                        *mut Worker_Connection,
                                                    entity_query:
                                                        *const Worker_EntityQuery,
                                                    timeout_millis:
                                                        *const u32)
     -> Worker_RequestId;
}
extern "C" {
    /**
 * Sends a component update for the given entity to SpatialOS. Note that the sent component update
 * is added as an operation to the operation list and will be returned by a subsequent call to
 * Worker_connection_GetOpList. The update data is copied with the corresponding vtable Copy
 * function and the copy is later freed with the vtable Free function.
 */
    pub fn Worker_Connection_SendComponentUpdate(connection:
                                                     *mut Worker_Connection,
                                                 entity_id: Worker_EntityId,
                                                 component_update:
                                                     *const Worker_ComponentUpdate);
}
extern "C" {
    /**
 * Sends a command request targeting the given entity and component to SpatialOS. If timeout_millis
 * is null, the default will be used. The request data is copied with the corresponding vtable Copy
 * function and the copy is later freed with the vtable Free function.
 *
 * The command_id parameter has no effect other than being exposed in the
 * Worker_CommandResponseOp so that callers can correctly handle command failures.
 *
 * The command parameters argument must not be NULL.
 */
    pub fn Worker_Connection_SendCommandRequest(connection:
                                                    *mut Worker_Connection,
                                                entity_id: Worker_EntityId,
                                                request:
                                                    *const Worker_CommandRequest,
                                                command_id: u32,
                                                timeout_millis: *const u32,
                                                command_parameters:
                                                    *const Worker_CommandParameters)
     -> Worker_RequestId;
}
extern "C" {
    /**
 * Sends a command response for the given request ID to SpatialOS. The response data is copied with
 * the corresponding vtable Copy function and the copy is later freed with the vtable Free function.
 */
    pub fn Worker_Connection_SendCommandResponse(connection:
                                                     *mut Worker_Connection,
                                                 request_id: Worker_RequestId,
                                                 response:
                                                     *const Worker_CommandResponse);
}
extern "C" {
    /** Sends an explicit failure for the given command request ID to SpatialOS. */
    pub fn Worker_Connection_SendCommandFailure(connection:
                                                    *mut Worker_Connection,
                                                request_id: Worker_RequestId,
                                                message:
                                                    *const ::std::os::raw::c_char);
}
extern "C" {
    /**
 * Sends a diff-based component interest update for the given entity to SpatialOS. By default, the
 * worker receives data for all entities according to the default component interest specified in
 * its bridge settings. This function allows interest override by (entity ID, component ID) pair to
 * force the data to either always be sent or never be sent. Note that this does not apply if the
 * worker is _authoritative_ over a particular (entity ID, component ID) pair, in which case the
 * data is always sent.
 */
    pub fn Worker_Connection_SendComponentInterest(connection:
                                                       *mut Worker_Connection,
                                                   entity_id: Worker_EntityId,
                                                   interest_override:
                                                       *const Worker_InterestOverride,
                                                   interest_override_count:
                                                       u32);
}
extern "C" {
    /**
 * Sends an acknowledgement of the receipt of an AuthorityLossImminent authority change for a
 * component. Sending the acknowledgement signifies that this worker is ready to lose authority
 * over the component.
 */
    pub fn Worker_Connection_SendAuthorityLossImminentAcknowledgement(connection:
                                                                          *mut Worker_Connection,
                                                                      entity_id:
                                                                          Worker_EntityId,
                                                                      component_id:
                                                                          Worker_ComponentId);
}
extern "C" {
    /**
 * Enables or disables protocol logging. Logging uses the parameters specified when the connection
 * was created. Enabling it when already enabled, or disabling it when already disabled, do nothing.
 *
 * Note that logs from any previous protocol logging sessions will be overwritten.
 */
    pub fn Worker_Connection_SetProtocolLoggingEnabled(connection:
                                                           *mut Worker_Connection,
                                                       enabled: u8);
}
extern "C" {
    /** Returns true if the connection has been successfully created and communication is ongoing. */
    pub fn Worker_Connection_IsConnected(connection: *const Worker_Connection)
     -> u8;
}
extern "C" {
    /**
 * Retrieves the ID of the worker as assigned by the runtime. The returned pointer points to data
 * that is owned by the SDK and will remain valid for the lifetime of the connection.
 */
    pub fn Worker_Connection_GetWorkerId(connection: *const Worker_Connection)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Retrieves the attributes associated with the worker at runtime. The result to data that is owned
 * by the SDK and will remain valid for the lifetime of the connection.
 */
    pub fn Worker_Connection_GetWorkerAttributes(connection:
                                                     *const Worker_Connection)
     -> *const Worker_WorkerAttributes;
}
extern "C" {
    /**
 * Queries the worker flag with the given name. If the worker flag does not exist, the value will
 * be NULL.
 *
 * Worker flags are remotely configurable and may change during the runtime of the worker,
 * including addition and deletion.
 */
    pub fn Worker_Connection_GetFlag(connection: *const Worker_Connection,
                                     name: *const ::std::os::raw::c_char,
                                     user_data: *mut ::std::os::raw::c_void,
                                     callback: Worker_GetFlagCallback);
}
extern "C" {
    /**
 * Retrieves the list of operations that have occurred since the last call to this function.
 *
 * If timeout_millis is non-zero, the function will block until there is at least one operation to
 * return, or the timeout has been exceeded. If the timeout is exceeded, an empty list will be
 * returned.
 *
 * If timeout_millis is zero the function is non-blocking.
 *
 * It is the caller's responsibility to destroy the returned Worker_OpList with the
 * Worker_OpList_Destroy function.
 */
    pub fn Worker_Connection_GetOpList(connection: *mut Worker_Connection,
                                       timeout_millis: u32)
     -> *mut Worker_OpList;
}
extern "C" {
    /** Frees resources for Worker_OpList returned by Worker_Connection_GetOpList. */
    pub fn Worker_OpList_Destroy(op_list: *mut Worker_OpList);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct Worker_SnapshotParameters {
    /** Number of component vtables. */
    pub component_vtable_count: u32,
    /** Component vtable for each component that the connection will deal with. */
    pub component_vtables: *const Worker_ComponentVtable,
    /** Default vtable used when a component is not registered. Only used if not NULL. */
    pub default_component_vtable: *const Worker_ComponentVtable,
}
#[test]
fn bindgen_test_layout_Worker_SnapshotParameters() {
    assert_eq!(::std::mem::size_of::<Worker_SnapshotParameters>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( Worker_SnapshotParameters ) ));
    assert_eq! (::std::mem::align_of::<Worker_SnapshotParameters>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( Worker_SnapshotParameters )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SnapshotParameters ) ) .
                component_vtable_count as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_SnapshotParameters ) , "::" , stringify ! (
                component_vtable_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SnapshotParameters ) ) .
                component_vtables as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                Worker_SnapshotParameters ) , "::" , stringify ! (
                component_vtables ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const Worker_SnapshotParameters ) ) .
                default_component_vtable as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                Worker_SnapshotParameters ) , "::" , stringify ! (
                default_component_vtable ) ));
}
impl Clone for Worker_SnapshotParameters {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    /**
 * Opens a Worker_SnapshotInputStream. The caller must manage the memory of the
 * returned Worker_SnapshotInputStream* by calling Worker_SnapshotInputStream to
 * write the EOF and release resources.
 *
 * If an error occurs, a pointer to a Worker_SnapshotInputStream is still returned.
 * Calling Worker_SnapshotInputStream_GetError with this pointer will return
 * an error message describing any error that occured. In the event of an error, the caller still
 * must release the memory of the Worker_SnapshotInputStream by calling
 * Worker_SnapshotInputStream.
 */
    pub fn Worker_SnapshotInputStream_Create(filename:
                                                 *const ::std::os::raw::c_char,
                                             params:
                                                 *const Worker_SnapshotParameters)
     -> *mut Worker_SnapshotInputStream;
}
extern "C" {
    /** Closes the SnapshotInputStream and releases its resources. */
    pub fn Worker_SnapshotInputStream_Destroy(input_stream:
                                                  *mut Worker_SnapshotInputStream);
}
extern "C" {
    /**
 * Returns zero (false) if the Worker_SnapshotInputStream has reached the EOF
 * of the Snapshot.
 */
    pub fn Worker_SnapshotInputStream_HasNext(input_stream:
                                                  *mut Worker_SnapshotInputStream)
     -> u8;
}
extern "C" {
    /**
 * Reads next Worker_Entity* entity from input_stream.
 *
 * Worker_SnapshotInputStream_ReadEntity manages the memory for the returned entity internally. The
 * next call to Worker_SnapshotInputStream_ReadEntity or Worker_SnapshotInputStream_Destroy
 * invalidates this value; use Worker_AcquireComponentData as usual to preserve component data.
 */
    pub fn Worker_SnapshotInputStream_ReadEntity(input_stream:
                                                     *mut Worker_SnapshotInputStream)
     -> *const Worker_Entity;
}
extern "C" {
    /**
 * Must be called after any operation on Worker_SnapshotInputStream to get the error
 * message associated with previous operation. If error is null, no error occured.
 *
 * Returns a read only const char* representation of the error message.
 */
    pub fn Worker_SnapshotInputStream_GetError(input_stream:
                                                   *mut Worker_SnapshotInputStream)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    /**
 * Opens Worker_SnapshotOutputStream stream. The caller must manage the memory of the
 * returned Worker_SnapshotOutputStream* by calling
 * Worker_SnapshotOutputStream_Destroy to write the EOF and release resources.
 *
 * If an error occurs, a pointer to a Worker_SnapshotOutputStream is still returned.
 * Calling Worker_SnapshotOutputStream_GetError with this pointer will return
 * an error message describing any error that occured. In the event of an error, the caller still
 * must release the memory of the Worker_SnapshotOutputStream by calling
 * Worker_SnapshotOutputStream_Destroy.
 */
    pub fn Worker_SnapshotOutputStream_Create(filename:
                                                  *const ::std::os::raw::c_char,
                                              params:
                                                  *const Worker_SnapshotParameters)
     -> *mut Worker_SnapshotOutputStream;
}
extern "C" {
    /** Closes the snapshot output stream and releases its resources. */
    pub fn Worker_SnapshotOutputStream_Destroy(output_stream:
                                                   *mut Worker_SnapshotOutputStream);
}
extern "C" {
    /**
 * Writes next entity_id, entity pair from input. Must call
 * Worker_SnapshotOutputStream_GetError
 * to get any error that occured during operation.
 * Returns non-zero (true) if the write was successful.
 */
    pub fn Worker_SnapshotOutputStream_WriteEntity(output_stream:
                                                       *mut Worker_SnapshotOutputStream,
                                                   entity:
                                                       *const Worker_Entity)
     -> u8;
}
extern "C" {
    /**
 * Must be called after any operation on Worker_SnapshotOutputStream to get the error
 * message associated with previous operation. If error is null, no error occured.
 *
 * Returns a read only const char* representation of the error message.
 */
    pub fn Worker_SnapshotOutputStream_GetError(output_stream:
                                                    *mut Worker_SnapshotOutputStream)
     -> *const ::std::os::raw::c_char;
}
pub type Schema_FieldId = u32;
pub type Schema_EntityId = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Schema_Object {
    _unused: [u8; 0],
}
extern "C" {
    /**
  * Allocate a command request schema type instance. The component ID should be as defined in
  * the schema, and the command_index should be the 1-based position of the command in the order
  * the commands appear in component in the schema.
  */
    pub fn Schema_CreateCommandRequest(component_id: Schema_FieldId,
                                       command_index: Schema_FieldId)
     -> *mut Schema_CommandRequest;
}
extern "C" {
    /** Free the resources associated with a command request schema type instance. */
    pub fn Schema_DestroyCommandRequest(request: *mut Schema_CommandRequest);
}
extern "C" {
    /** Get the component ID of a command request. */
    pub fn Schema_GetCommandRequestComponentId(request:
                                                   *const Schema_CommandRequest)
     -> Schema_FieldId;
}
extern "C" {
    /** Get the 1-based position of the command in the order the commands appear in the schema. */
    pub fn Schema_GetCommandRequestCommandIndex(request:
                                                    *const Schema_CommandRequest)
     -> Schema_FieldId;
}
extern "C" {
    /** Get the command request as a Schema_Object. */
    pub fn Schema_GetCommandRequestObject(request: *mut Schema_CommandRequest)
     -> *mut Schema_Object;
}
extern "C" {
    /**
  * Allocate a command response schema type instance. The component ID should be as defined in
  * the schema, and the command_index should be the 1-based position of the command in the order
  * the commands appear in the component in schema.
  */
    pub fn Schema_CreateCommandResponse(component_id: Schema_FieldId,
                                        command_index: Schema_FieldId)
     -> *mut Schema_CommandResponse;
}
extern "C" {
    /** Free the resources associated with a command response schema type instance. */
    pub fn Schema_DestroyCommandResponse(response:
                                             *mut Schema_CommandResponse);
}
extern "C" {
    /** Get the component ID of a command response. */
    pub fn Schema_GetCommandResponseComponentId(request:
                                                    *const Schema_CommandResponse)
     -> Schema_FieldId;
}
extern "C" {
    /** Get the 1-based position of the command in the order the commands appear in the schema. */
    pub fn Schema_GetCommandResponseCommandIndex(request:
                                                     *const Schema_CommandResponse)
     -> Schema_FieldId;
}
extern "C" {
    /** Get the command response as a Schema_Object. */
    pub fn Schema_GetCommandResponseObject(response:
                                               *mut Schema_CommandResponse)
     -> *mut Schema_Object;
}
extern "C" {
    /** Allocate a component data snapshot schema type instance. */
    pub fn Schema_CreateComponentData(component_id: Schema_FieldId)
     -> *mut Schema_ComponentData;
}
extern "C" {
    /** Free the resources associated with a component data snapshot schema type instance. */
    pub fn Schema_DestroyComponentData(data: *mut Schema_ComponentData);
}
extern "C" {
    /** Get the component ID of a component data snapshot. */
    pub fn Schema_GetComponentDataComponentId(data:
                                                  *const Schema_ComponentData)
     -> Schema_FieldId;
}
extern "C" {
    /** Get the command data snapshot as a Schema_Object. */
    pub fn Schema_GetComponentDataFields(data: *mut Schema_ComponentData)
     -> *mut Schema_Object;
}
extern "C" {
    /** Allocate a component update schema type instance. */
    pub fn Schema_CreateComponentUpdate(component_id: Schema_FieldId)
     -> *mut Schema_ComponentUpdate;
}
extern "C" {
    /** Free the resources associated with a component update schema type instance. */
    pub fn Schema_DestroyComponentUpdate(update: *mut Schema_ComponentUpdate);
}
extern "C" {
    /** Get the component ID of a component update. */
    pub fn Schema_GetComponentUpdateComponentId(update:
                                                    *const Schema_ComponentUpdate)
     -> Schema_FieldId;
}
extern "C" {
    /**
 * Get an object representing the non-event fields in a component update. This object should be used
 * as if it had one field for each field in the component, whose type corresponds to the type of the
 * field as defined in schema. Note that when an option, list or map field in a component is set to
 * the empty value, it will not / should not appear here. Instead, use
 * Schema_IndexComponentUpdateClearedField and related functions.
 */
    pub fn Schema_GetComponentUpdateFields(update:
                                               *mut Schema_ComponentUpdate)
     -> *mut Schema_Object;
}
extern "C" {
    /**
 * Get an object representing the event fields in a component update. This object should be used
 * as if it had one field for each event in the component. Each field behaves like a list (may have
 * multiple instances of the same event), and the field ID of an event is its 1-based position in
 * the order the events appear in the component in the schema.
 */
    pub fn Schema_GetComponentUpdateEvents(update:
                                               *mut Schema_ComponentUpdate)
     -> *mut Schema_Object;
}
extern "C" {
    /**
 * Clears the list of fields that this update sets to the empty value (for option, list and map
 * fields in a component).
 */
    pub fn Schema_ClearComponentUpdateClearedFields(update:
                                                        *mut Schema_ComponentUpdate);
}
extern "C" {
    /**
  * Specifies that this update sets and option, list or map field in a component to the empty
  * value.
  */
    pub fn Schema_AddComponentUpdateClearedField(update:
                                                     *mut Schema_ComponentUpdate,
                                                 field_id: Schema_FieldId);
}
extern "C" {
    /**
 * Returns the number of option, list and map fields in a component that this update sets to the
 * empty value.
 */
    pub fn Schema_GetComponentUpdateClearedFieldCount(update:
                                                          *const Schema_ComponentUpdate)
     -> u32;
}
extern "C" {
    /**
 * Returns the field ID of an option, list or map field which is set to the empty value by this
 * update.
 */
    pub fn Schema_IndexComponentUpdateClearedField(update:
                                                       *const Schema_ComponentUpdate,
                                                   index: u32)
     -> Schema_FieldId;
}
extern "C" {
    /**
 * Returns all field IDs of option, list, or map fields which are set to the empty value by this
 * component. The output_array should have space for
 * Schema_GetComponentUpdateClearedFieldCount(update) field IDs.
 */
    pub fn Schema_GetComponentUpdateClearedFieldList(update:
                                                         *const Schema_ComponentUpdate,
                                                     output_array:
                                                         *mut Schema_FieldId);
}
extern "C" {
    /** Completely clears all fields in the given object. */
    pub fn Schema_Clear(object: *mut Schema_Object);
}
extern "C" {
    /** Completely clears the given field ID in the given object. */
    pub fn Schema_ClearField(object: *mut Schema_Object,
                             field_id: Schema_FieldId);
}
extern "C" {
    /**
 * Copies all fields from `src` to `dst`. The copy is shallow; changes made to object fields in the
 * source will also be reflected in the copied fields.
 *
 * If `src == dst`, or if the objects are not associated with the same root schema type instance, no
 * operation is performed.
 */
    pub fn Schema_ShallowCopy(src: *const Schema_Object,
                              dst: *mut Schema_Object);
}
extern "C" {
    /**
 * Copies over a field from `src` to `dst`. If multiple fields with the given field_id exist all
 * are copied. The copy is shallow; changes made to object fields in the source will also be
 * reflected in the copied fields.
 *
 * If `src == dst`, or if the objects are not associated with the same root schema type instance, no
 * operation is performed.
 */
    pub fn Schema_ShallowCopyField(src: *const Schema_Object,
                                   dst: *mut Schema_Object,
                                   field_id: Schema_FieldId);
}
extern "C" {
    /**
 * Allocates an orphaned Schema_Object in memory owned by the given Schema_Object instance. The
 * returned object is owned by the associated schema type instance, but is not reachable from any
 * other object. The memory is freed by a call to Schema_Destroy.
 */
    pub fn Schema_AllocateObject(object: *const Schema_Object)
     -> *mut Schema_Object;
}
extern "C" {
    /**
 * Allocates a buffer of the specified length in bytes from memory owned by the given Schema_Object
 * instance. The memory is freed by a call to Schema_Destroy.
 *
 * Note: this is useful for allocating memory that must live as long as the root schema type
 * instance, for example to pass to Schema_MergeFromBuffer.
 */
    pub fn Schema_AllocateBuffer(object: *mut Schema_Object, length: u32)
     -> *mut u8;
}
extern "C" {
    /**
 * Merges the given buffer into the given object, appending all fields. This function
 * can fail; if the return value is zero, call Schema_GetError to obtain an error string.
 *
 * Note: the provided buffer is not copied, and must live as long as the root schema type instance.
 */
    pub fn Schema_MergeFromBuffer(object: *mut Schema_Object,
                                  buffer: *const u8, length: u32) -> u8;
}
extern "C" {
    /** Computes the serialized length of the given Schema_Object. */
    pub fn Schema_GetWriteBufferLength(object: *const Schema_Object) -> u32;
}
extern "C" {
    /**
 * Serializes the given object into the provided buffer, which _must_ have space at
 * least equal to the length returned by Schema_WriteBufferLength. This function can
 * fail; if the return value is zero, call Schema_GetError to obtain an error string.
 */
    pub fn Schema_WriteToBuffer(object: *const Schema_Object, buffer: *mut u8)
     -> u8;
}
extern "C" {
    /** Returns the number of unique field IDs used in the Schema_Object. */
    pub fn Schema_GetUniqueFieldIdCount(object: *const Schema_Object) -> u32;
}
extern "C" {
    /**
 * Returns the sorted list of unique field IDs used in the Schema_Object. The buffer parameter
 * must have space remaining for as many field IDs as indicated by Schema_GetUniqueFieldIdCount.
 */
    pub fn Schema_GetUniqueFieldIds(object: *const Schema_Object,
                                    buffer: *mut u32);
}
extern "C" {
    pub fn Schema_AddFloat(object: *mut Schema_Object,
                           field_id: Schema_FieldId, value: f32);
}
extern "C" {
    pub fn Schema_AddDouble(object: *mut Schema_Object,
                            field_id: Schema_FieldId, value: f64);
}
extern "C" {
    pub fn Schema_AddBool(object: *mut Schema_Object,
                          field_id: Schema_FieldId, value: u8);
}
extern "C" {
    pub fn Schema_AddInt32(object: *mut Schema_Object,
                           field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddInt64(object: *mut Schema_Object,
                           field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddUint32(object: *mut Schema_Object,
                            field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddUint64(object: *mut Schema_Object,
                            field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSint32(object: *mut Schema_Object,
                            field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSint64(object: *mut Schema_Object,
                            field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddFixed32(object: *mut Schema_Object,
                             field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddFixed64(object: *mut Schema_Object,
                             field_id: Schema_FieldId, value: u64);
}
extern "C" {
    pub fn Schema_AddSfixed32(object: *mut Schema_Object,
                              field_id: Schema_FieldId, value: i32);
}
extern "C" {
    pub fn Schema_AddSfixed64(object: *mut Schema_Object,
                              field_id: Schema_FieldId, value: i64);
}
extern "C" {
    pub fn Schema_AddEntityId(object: *mut Schema_Object,
                              field_id: Schema_FieldId,
                              value: Schema_EntityId);
}
extern "C" {
    pub fn Schema_AddEnum(object: *mut Schema_Object,
                          field_id: Schema_FieldId, value: u32);
}
extern "C" {
    pub fn Schema_AddBytes(object: *mut Schema_Object,
                           field_id: Schema_FieldId, buffer: *const u8,
                           length: u32);
}
extern "C" {
    pub fn Schema_AddObject(object: *mut Schema_Object,
                            field_id: Schema_FieldId) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_AddFloatList(object: *mut Schema_Object,
                               field_id: Schema_FieldId, values: *const f32,
                               count: u32);
}
extern "C" {
    pub fn Schema_AddDoubleList(object: *mut Schema_Object,
                                field_id: Schema_FieldId, values: *const f64,
                                count: u32);
}
extern "C" {
    pub fn Schema_AddBoolList(object: *mut Schema_Object,
                              field_id: Schema_FieldId, values: *const u8,
                              count: u32);
}
extern "C" {
    pub fn Schema_AddInt32List(object: *mut Schema_Object,
                               field_id: Schema_FieldId, values: *const i32,
                               count: u32);
}
extern "C" {
    pub fn Schema_AddInt64List(object: *mut Schema_Object,
                               field_id: Schema_FieldId, values: *const i64,
                               count: u32);
}
extern "C" {
    pub fn Schema_AddUint32List(object: *mut Schema_Object,
                                field_id: Schema_FieldId, values: *const u32,
                                count: u32);
}
extern "C" {
    pub fn Schema_AddUint64List(object: *mut Schema_Object,
                                field_id: Schema_FieldId, values: *const u64,
                                count: u32);
}
extern "C" {
    pub fn Schema_AddSint32List(object: *mut Schema_Object,
                                field_id: Schema_FieldId, values: *const i32,
                                count: u32);
}
extern "C" {
    pub fn Schema_AddSint64List(object: *mut Schema_Object,
                                field_id: Schema_FieldId, values: *const i64,
                                count: u32);
}
extern "C" {
    pub fn Schema_AddFixed32List(object: *mut Schema_Object,
                                 field_id: Schema_FieldId, values: *const u32,
                                 count: u32);
}
extern "C" {
    pub fn Schema_AddFixed64List(object: *mut Schema_Object,
                                 field_id: Schema_FieldId, values: *const u64,
                                 count: u32);
}
extern "C" {
    pub fn Schema_AddSfixed32List(object: *mut Schema_Object,
                                  field_id: Schema_FieldId,
                                  values: *const i32, count: u32);
}
extern "C" {
    pub fn Schema_AddSfixed64List(object: *mut Schema_Object,
                                  field_id: Schema_FieldId,
                                  values: *const i64, count: u32);
}
extern "C" {
    pub fn Schema_AddEntityIdList(object: *mut Schema_Object,
                                  field_id: Schema_FieldId,
                                  values: *const Schema_EntityId, count: u32);
}
extern "C" {
    pub fn Schema_AddEnumList(object: *mut Schema_Object,
                              field_id: Schema_FieldId, values: *const u32,
                              count: u32);
}
extern "C" {
    pub fn Schema_GetFloatCount(object: *const Schema_Object,
                                field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetDoubleCount(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBoolCount(object: *const Schema_Object,
                               field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt32Count(object: *const Schema_Object,
                                field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetInt64Count(object: *const Schema_Object,
                                field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint32Count(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64Count(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint32Count(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSint64Count(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed32Count(object: *const Schema_Object,
                                  field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64Count(object: *const Schema_Object,
                                  field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed32Count(object: *const Schema_Object,
                                   field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetSfixed64Count(object: *const Schema_Object,
                                   field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEntityIdCount(object: *const Schema_Object,
                                   field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetEnumCount(object: *const Schema_Object,
                               field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesCount(object: *const Schema_Object,
                                field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetObjectCount(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFloat(object: *const Schema_Object,
                           field_id: Schema_FieldId) -> f32;
}
extern "C" {
    pub fn Schema_GetDouble(object: *const Schema_Object,
                            field_id: Schema_FieldId) -> f64;
}
extern "C" {
    pub fn Schema_GetBool(object: *const Schema_Object,
                          field_id: Schema_FieldId) -> u8;
}
extern "C" {
    pub fn Schema_GetInt32(object: *const Schema_Object,
                           field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetInt64(object: *const Schema_Object,
                           field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetUint32(object: *const Schema_Object,
                            field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetUint64(object: *const Schema_Object,
                            field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSint32(object: *const Schema_Object,
                            field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSint64(object: *const Schema_Object,
                            field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetFixed32(object: *const Schema_Object,
                             field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetFixed64(object: *const Schema_Object,
                             field_id: Schema_FieldId) -> u64;
}
extern "C" {
    pub fn Schema_GetSfixed32(object: *const Schema_Object,
                              field_id: Schema_FieldId) -> i32;
}
extern "C" {
    pub fn Schema_GetSfixed64(object: *const Schema_Object,
                              field_id: Schema_FieldId) -> i64;
}
extern "C" {
    pub fn Schema_GetEntityId(object: *const Schema_Object,
                              field_id: Schema_FieldId) -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_GetEnum(object: *const Schema_Object,
                          field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytesLength(object: *const Schema_Object,
                                 field_id: Schema_FieldId) -> u32;
}
extern "C" {
    pub fn Schema_GetBytes(object: *const Schema_Object,
                           field_id: Schema_FieldId) -> *const u8;
}
extern "C" {
    pub fn Schema_GetObject(object: *mut Schema_Object,
                            field_id: Schema_FieldId) -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_IndexFloat(object: *const Schema_Object,
                             field_id: Schema_FieldId, index: u32) -> f32;
}
extern "C" {
    pub fn Schema_IndexDouble(object: *const Schema_Object,
                              field_id: Schema_FieldId, index: u32) -> f64;
}
extern "C" {
    pub fn Schema_IndexBool(object: *const Schema_Object,
                            field_id: Schema_FieldId, index: u32) -> u8;
}
extern "C" {
    pub fn Schema_IndexInt32(object: *const Schema_Object,
                             field_id: Schema_FieldId, index: u32) -> i32;
}
extern "C" {
    pub fn Schema_IndexInt64(object: *const Schema_Object,
                             field_id: Schema_FieldId, index: u32) -> i64;
}
extern "C" {
    pub fn Schema_IndexUint32(object: *const Schema_Object,
                              field_id: Schema_FieldId, index: u32) -> u32;
}
extern "C" {
    pub fn Schema_IndexUint64(object: *const Schema_Object,
                              field_id: Schema_FieldId, index: u32) -> u64;
}
extern "C" {
    pub fn Schema_IndexSint32(object: *const Schema_Object,
                              field_id: Schema_FieldId, index: u32) -> i32;
}
extern "C" {
    pub fn Schema_IndexSint64(object: *const Schema_Object,
                              field_id: Schema_FieldId, index: u32) -> i64;
}
extern "C" {
    pub fn Schema_IndexFixed32(object: *const Schema_Object,
                               field_id: Schema_FieldId, index: u32) -> u32;
}
extern "C" {
    pub fn Schema_IndexFixed64(object: *const Schema_Object,
                               field_id: Schema_FieldId, index: u32) -> u64;
}
extern "C" {
    pub fn Schema_IndexSfixed32(object: *const Schema_Object,
                                field_id: Schema_FieldId, index: u32) -> i32;
}
extern "C" {
    pub fn Schema_IndexSfixed64(object: *const Schema_Object,
                                field_id: Schema_FieldId, index: u32) -> i64;
}
extern "C" {
    pub fn Schema_IndexEntityId(object: *const Schema_Object,
                                field_id: Schema_FieldId, index: u32)
     -> Schema_EntityId;
}
extern "C" {
    pub fn Schema_IndexEnum(object: *const Schema_Object,
                            field_id: Schema_FieldId, index: u32) -> u32;
}
extern "C" {
    pub fn Schema_IndexBytesLength(object: *const Schema_Object,
                                   field_id: Schema_FieldId, index: u32)
     -> u32;
}
extern "C" {
    pub fn Schema_IndexBytes(object: *const Schema_Object,
                             field_id: Schema_FieldId, index: u32)
     -> *const u8;
}
extern "C" {
    pub fn Schema_IndexObject(object: *mut Schema_Object,
                              field_id: Schema_FieldId, index: u32)
     -> *mut Schema_Object;
}
extern "C" {
    pub fn Schema_GetFloatList(object: *const Schema_Object,
                               field_id: Schema_FieldId,
                               output_array: *mut f32);
}
extern "C" {
    pub fn Schema_GetDoubleList(object: *const Schema_Object,
                                field_id: Schema_FieldId,
                                output_array: *mut f64);
}
extern "C" {
    pub fn Schema_GetBoolList(object: *const Schema_Object,
                              field_id: Schema_FieldId,
                              output_array: *mut u8);
}
extern "C" {
    pub fn Schema_GetInt32List(object: *const Schema_Object,
                               field_id: Schema_FieldId,
                               output_array: *mut i32);
}
extern "C" {
    pub fn Schema_GetInt64List(object: *const Schema_Object,
                               field_id: Schema_FieldId,
                               output_array: *mut i64);
}
extern "C" {
    pub fn Schema_GetUint32List(object: *const Schema_Object,
                                field_id: Schema_FieldId,
                                output_array: *mut u32);
}
extern "C" {
    pub fn Schema_GetUint64List(object: *const Schema_Object,
                                field_id: Schema_FieldId,
                                output_array: *mut u64);
}
extern "C" {
    pub fn Schema_GetSint32List(object: *const Schema_Object,
                                field_id: Schema_FieldId,
                                output_array: *mut i32);
}
extern "C" {
    pub fn Schema_GetSint64List(object: *const Schema_Object,
                                field_id: Schema_FieldId,
                                output_array: *mut i64);
}
extern "C" {
    pub fn Schema_GetFixed32List(object: *const Schema_Object,
                                 field_id: Schema_FieldId,
                                 output_array: *mut u32);
}
extern "C" {
    pub fn Schema_GetFixed64List(object: *const Schema_Object,
                                 field_id: Schema_FieldId,
                                 output_array: *mut u64);
}
extern "C" {
    pub fn Schema_GetSfixed32List(object: *const Schema_Object,
                                  field_id: Schema_FieldId,
                                  output_array: *mut i32);
}
extern "C" {
    pub fn Schema_GetSfixed64List(object: *const Schema_Object,
                                  field_id: Schema_FieldId,
                                  output_array: *mut i64);
}
extern "C" {
    pub fn Schema_GetEntityIdList(object: *const Schema_Object,
                                  field_id: Schema_FieldId,
                                  output_array: *mut Schema_EntityId);
}
extern "C" {
    pub fn Schema_GetEnumList(object: *const Schema_Object,
                              field_id: Schema_FieldId,
                              output_array: *mut u32);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
